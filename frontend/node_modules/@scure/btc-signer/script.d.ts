import * as P from 'micro-packed';
import { type ValueOf, type Bytes } from './utils.ts';
export declare const MAX_SCRIPT_BYTE_LENGTH = 520;
export declare const OP: {
    OP_0: number;
    PUSHDATA1: number;
    PUSHDATA2: number;
    PUSHDATA4: number;
    '1NEGATE': number;
    RESERVED: number;
    OP_1: number;
    OP_2: number;
    OP_3: number;
    OP_4: number;
    OP_5: number;
    OP_6: number;
    OP_7: number;
    OP_8: number;
    OP_9: number;
    OP_10: number;
    OP_11: number;
    OP_12: number;
    OP_13: number;
    OP_14: number;
    OP_15: number;
    OP_16: number;
    NOP: number;
    VER: number;
    IF: number;
    NOTIF: number;
    VERIF: number;
    VERNOTIF: number;
    ELSE: number;
    ENDIF: number;
    VERIFY: number;
    RETURN: number;
    TOALTSTACK: number;
    FROMALTSTACK: number;
    '2DROP': number;
    '2DUP': number;
    '3DUP': number;
    '2OVER': number;
    '2ROT': number;
    '2SWAP': number;
    IFDUP: number;
    DEPTH: number;
    DROP: number;
    DUP: number;
    NIP: number;
    OVER: number;
    PICK: number;
    ROLL: number;
    ROT: number;
    SWAP: number;
    TUCK: number;
    CAT: number;
    SUBSTR: number;
    LEFT: number;
    RIGHT: number;
    SIZE: number;
    INVERT: number;
    AND: number;
    OR: number;
    XOR: number;
    EQUAL: number;
    EQUALVERIFY: number;
    RESERVED1: number;
    RESERVED2: number;
    '1ADD': number;
    '1SUB': number;
    '2MUL': number;
    '2DIV': number;
    NEGATE: number;
    ABS: number;
    NOT: number;
    '0NOTEQUAL': number;
    ADD: number;
    SUB: number;
    MUL: number;
    DIV: number;
    MOD: number;
    LSHIFT: number;
    RSHIFT: number;
    BOOLAND: number;
    BOOLOR: number;
    NUMEQUAL: number;
    NUMEQUALVERIFY: number;
    NUMNOTEQUAL: number;
    LESSTHAN: number;
    GREATERTHAN: number;
    LESSTHANOREQUAL: number;
    GREATERTHANOREQUAL: number;
    MIN: number;
    MAX: number;
    WITHIN: number;
    RIPEMD160: number;
    SHA1: number;
    SHA256: number;
    HASH160: number;
    HASH256: number;
    CODESEPARATOR: number;
    CHECKSIG: number;
    CHECKSIGVERIFY: number;
    CHECKMULTISIG: number;
    CHECKMULTISIGVERIFY: number;
    NOP1: number;
    CHECKLOCKTIMEVERIFY: number;
    CHECKSEQUENCEVERIFY: number;
    NOP4: number;
    NOP5: number;
    NOP6: number;
    NOP7: number;
    NOP8: number;
    NOP9: number;
    NOP10: number;
    CHECKSIGADD: number;
    INVALID: number;
};
export declare const OPNames: {
    [x: number]: "OP_0" | "PUSHDATA1" | "PUSHDATA2" | "PUSHDATA4" | "1NEGATE" | "RESERVED" | "OP_1" | "OP_2" | "OP_3" | "OP_4" | "OP_5" | "OP_6" | "OP_7" | "OP_8" | "OP_9" | "OP_10" | "OP_11" | "OP_12" | "OP_13" | "OP_14" | "OP_15" | "OP_16" | "NOP" | "VER" | "IF" | "NOTIF" | "VERIF" | "VERNOTIF" | "ELSE" | "ENDIF" | "VERIFY" | "RETURN" | "TOALTSTACK" | "FROMALTSTACK" | "2DROP" | "2DUP" | "3DUP" | "2OVER" | "2ROT" | "2SWAP" | "IFDUP" | "DEPTH" | "DROP" | "DUP" | "NIP" | "OVER" | "PICK" | "ROLL" | "ROT" | "SWAP" | "TUCK" | "CAT" | "SUBSTR" | "LEFT" | "RIGHT" | "SIZE" | "INVERT" | "AND" | "OR" | "XOR" | "EQUAL" | "EQUALVERIFY" | "RESERVED1" | "RESERVED2" | "1ADD" | "1SUB" | "2MUL" | "2DIV" | "NEGATE" | "ABS" | "NOT" | "0NOTEQUAL" | "ADD" | "SUB" | "MUL" | "DIV" | "MOD" | "LSHIFT" | "RSHIFT" | "BOOLAND" | "BOOLOR" | "NUMEQUAL" | "NUMEQUALVERIFY" | "NUMNOTEQUAL" | "LESSTHAN" | "GREATERTHAN" | "LESSTHANOREQUAL" | "GREATERTHANOREQUAL" | "MIN" | "MAX" | "WITHIN" | "RIPEMD160" | "SHA1" | "SHA256" | "HASH160" | "HASH256" | "CODESEPARATOR" | "CHECKSIG" | "CHECKSIGVERIFY" | "CHECKMULTISIG" | "CHECKMULTISIGVERIFY" | "NOP1" | "CHECKLOCKTIMEVERIFY" | "CHECKSEQUENCEVERIFY" | "NOP4" | "NOP5" | "NOP6" | "NOP7" | "NOP8" | "NOP9" | "NOP10" | "CHECKSIGADD" | "INVALID";
};
export type OP = ValueOf<typeof OP>;
export type ScriptOP = keyof typeof OP | Uint8Array | number;
export type ScriptType = ScriptOP[];
export declare function ScriptNum(bytesLimit?: number, forceMinimal?: boolean): P.CoderType<bigint>;
export declare function OpToNum(op: ScriptOP, bytesLimit?: number, forceMinimal?: boolean): number | undefined;
export declare const Script: P.CoderType<ScriptType>;
export declare const CompactSize: P.CoderType<bigint>;
export declare const CompactSizeLen: P.CoderType<number>;
export declare const VarBytes: P.CoderType<Bytes>;
export declare const RawWitness: P.CoderType<Bytes[]>;
export declare const BTCArray: <T>(t: P.CoderType<T>) => P.CoderType<T[]>;
export declare const RawInput: P.CoderType<P.StructInput<{
    txid: P.Bytes;
    index: number;
    finalScriptSig: Bytes;
    sequence: number;
}>>;
export declare const RawOutput: P.CoderType<P.StructInput<{
    amount: bigint;
    script: Bytes;
}>>;
declare const _RawTx: P.CoderType<P.StructInput<{
    version: number;
    segwitFlag: boolean | undefined;
    inputs: P.StructInput<{
        txid: /*elided*/ any;
        index: /*elided*/ any;
        finalScriptSig: /*elided*/ any;
        sequence: /*elided*/ any;
    }>[];
    outputs: P.StructInput<{
        amount: /*elided*/ any;
        script: /*elided*/ any;
    }>[];
    witnesses: P.Option<Bytes[][]>;
    lockTime: number;
}>>;
export declare const RawTx: typeof _RawTx;
export declare const RawOldTx: P.CoderType<P.StructInput<{
    version: number;
    inputs: P.StructInput<{
        txid: /*elided*/ any;
        index: /*elided*/ any;
        finalScriptSig: /*elided*/ any;
        sequence: /*elided*/ any;
    }>[];
    outputs: P.StructInput<{
        amount: /*elided*/ any;
        script: /*elided*/ any;
    }>[];
    lockTime: number;
}>>;
export {};
//# sourceMappingURL=script.d.ts.map