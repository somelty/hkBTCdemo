// src/provider/types.ts
import * as v4 from "valibot";

// src/addresses/index.ts
import { createUnsecuredToken } from "jsontokens";

// src/addresses/types.ts
import * as v2 from "valibot";

// src/request/types/common.ts
import * as v from "valibot";
var walletTypes = ["software", "ledger", "keystone"];
var walletTypeSchema = v.picklist(walletTypes);

// src/addresses/types.ts
var AddressPurpose = /* @__PURE__ */ ((AddressPurpose2) => {
  AddressPurpose2["Ordinals"] = "ordinals";
  AddressPurpose2["Payment"] = "payment";
  AddressPurpose2["Stacks"] = "stacks";
  return AddressPurpose2;
})(AddressPurpose || {});
var AddressType = /* @__PURE__ */ ((AddressType3) => {
  AddressType3["p2pkh"] = "p2pkh";
  AddressType3["p2sh"] = "p2sh";
  AddressType3["p2wpkh"] = "p2wpkh";
  AddressType3["p2wsh"] = "p2wsh";
  AddressType3["p2tr"] = "p2tr";
  AddressType3["stacks"] = "stacks";
  return AddressType3;
})(AddressType || {});
var addressSchema = v2.object({
  address: v2.string(),
  publicKey: v2.string(),
  purpose: v2.enum(AddressPurpose),
  addressType: v2.enum(AddressType),
  walletType: walletTypeSchema
});

// src/addresses/index.ts
var getAddress = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { purposes } = options.payload;
  if (!purposes) {
    throw new Error("Address purposes are required");
  }
  try {
    const request2 = createUnsecuredToken(options.payload);
    const response = await provider.connect(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during address request", error);
    options.onCancel?.();
  }
};

// src/types.ts
import * as v3 from "valibot";
var BitcoinNetworkType = /* @__PURE__ */ ((BitcoinNetworkType2) => {
  BitcoinNetworkType2["Mainnet"] = "Mainnet";
  BitcoinNetworkType2["Testnet"] = "Testnet";
  BitcoinNetworkType2["Testnet4"] = "Testnet4";
  BitcoinNetworkType2["Signet"] = "Signet";
  BitcoinNetworkType2["Regtest"] = "Regtest";
  return BitcoinNetworkType2;
})(BitcoinNetworkType || {});
var StacksNetworkType = /* @__PURE__ */ ((StacksNetworkType2) => {
  StacksNetworkType2["Mainnet"] = "mainnet";
  StacksNetworkType2["Testnet"] = "testnet";
  return StacksNetworkType2;
})(StacksNetworkType || {});
var StarknetNetworkType = /* @__PURE__ */ ((StarknetNetworkType2) => {
  StarknetNetworkType2["Mainnet"] = "mainnet";
  StarknetNetworkType2["Sepolia"] = "sepolia";
  return StarknetNetworkType2;
})(StarknetNetworkType || {});
var RpcIdSchema = v3.optional(v3.union([v3.string(), v3.number(), v3.null()]));
var rpcRequestMessageSchema = v3.object({
  jsonrpc: v3.literal("2.0"),
  method: v3.string(),
  params: v3.optional(
    v3.union([
      v3.array(v3.unknown()),
      v3.looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      v3.null()
    ])
  ),
  id: v3.unwrap(RpcIdSchema)
});
var RpcErrorCode = /* @__PURE__ */ ((RpcErrorCode2) => {
  RpcErrorCode2[RpcErrorCode2["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
  RpcErrorCode2[RpcErrorCode2["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
  RpcErrorCode2[RpcErrorCode2["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
  RpcErrorCode2[RpcErrorCode2["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
  RpcErrorCode2[RpcErrorCode2["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
  RpcErrorCode2[RpcErrorCode2["USER_REJECTION"] = -32e3] = "USER_REJECTION";
  RpcErrorCode2[RpcErrorCode2["METHOD_NOT_SUPPORTED"] = -32001] = "METHOD_NOT_SUPPORTED";
  RpcErrorCode2[RpcErrorCode2["ACCESS_DENIED"] = -32002] = "ACCESS_DENIED";
  return RpcErrorCode2;
})(RpcErrorCode || {});
var rpcSuccessResponseMessageSchema = v3.object({
  jsonrpc: v3.literal("2.0"),
  result: v3.nonOptional(v3.unknown()),
  id: RpcIdSchema
});
var rpcErrorResponseMessageSchema = v3.object({
  jsonrpc: v3.literal("2.0"),
  error: v3.nonOptional(v3.unknown()),
  id: RpcIdSchema
});
var rpcResponseMessageSchema = v3.union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);

// src/provider/types.ts
var accountChangeEventName = "accountChange";
var accountChangeSchema = v4.object({
  type: v4.literal(accountChangeEventName),
  addresses: v4.optional(v4.array(addressSchema))
});
var networkChangeEventName = "networkChange";
var networkChangeSchema = v4.object({
  type: v4.literal(networkChangeEventName),
  bitcoin: v4.object({
    name: v4.enum(BitcoinNetworkType)
  }),
  stacks: v4.object({
    name: v4.string()
  }),
  addresses: v4.optional(v4.array(addressSchema))
});
var disconnectEventName = "disconnect";
var disconnectSchema = v4.object({
  type: v4.literal(disconnectEventName)
});
var walletEventSchema = v4.variant("type", [
  accountChangeSchema,
  networkChangeSchema,
  disconnectSchema
]);

// src/provider/index.ts
async function getProviderOrThrow(getProvider) {
  const provider = await getProvider?.() || window.XverseProviders?.BitcoinProvider || window.BitcoinProvider;
  if (!provider) {
    throw new Error("No Bitcoin wallet installed");
  }
  return provider;
}
function getProviders() {
  if (!window.btc_providers) window.btc_providers = [];
  return window.btc_providers;
}
function getProviderById(providerId) {
  return providerId?.split(".").reduce((acc, part) => acc?.[part], window);
}
function isProviderInstalled(providerId) {
  return !!getProviderById(providerId);
}
function setDefaultProvider(providerId) {
  localStorage.setItem("sats-connect_defaultProvider", providerId);
}
function getDefaultProvider() {
  return localStorage.getItem("sats-connect_defaultProvider");
}
function removeDefaultProvider() {
  localStorage.removeItem("sats-connect_defaultProvider");
}
function getSupportedWallets() {
  const wallets = Object.values(DefaultAdaptersInfo).map((provider) => {
    {
      return {
        ...provider,
        isInstalled: isProviderInstalled(provider.id)
      };
    }
  });
  return wallets;
}

// src/request/index.ts
import * as v21 from "valibot";

// src/request/types/stxMethods/callContract.ts
import * as v5 from "valibot";
var stxCallContractMethodName = "stx_callContract";
var stxCallContractParamsSchema = v5.object({
  /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */
  contract: v5.string(),
  /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */
  functionName: v5.string(),
  /**
   * @deprecated in favor of `functionArgs` for @stacks/connect compatibility
   */
  arguments: v5.optional(v5.array(v5.string())),
  /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */
  functionArgs: v5.optional(v5.array(v5.string())),
  /**
   * The post conditions to apply to the contract call.
   */
  postConditions: v5.optional(v5.array(v5.string())),
  /**
   * The mode to apply to the post conditions.
   */
  postConditionMode: v5.optional(v5.union([v5.literal("allow"), v5.literal("deny")]))
});
var stxCallContractResultSchema = v5.object({
  /**
   * The ID of the transaction.
   */
  txid: v5.string(),
  /**
   * A Stacks transaction as a hex-encoded string.
   */
  transaction: v5.string()
});
var stxCallContractRequestMessageSchema = v5.object({
  ...rpcRequestMessageSchema.entries,
  ...v5.object({
    method: v5.literal(stxCallContractMethodName),
    params: stxCallContractParamsSchema,
    id: v5.string()
  }).entries
});

// src/request/types/stxMethods/deployContract.ts
import * as v6 from "valibot";
var stxDeployContractMethodName = "stx_deployContract";
var stxDeployContractParamsSchema = v6.object({
  /**
   * Name of the contract.
   */
  name: v6.string(),
  /**
   * The source code of the Clarity contract.
   */
  clarityCode: v6.string(),
  /**
   * The version of the Clarity contract.
   */
  clarityVersion: v6.optional(v6.number()),
  /**
   * The post conditions to apply to the contract call.
   */
  postConditions: v6.optional(v6.array(v6.string())),
  /**
   * The mode to apply to the post conditions.
   */
  postConditionMode: v6.optional(v6.union([v6.literal("allow"), v6.literal("deny")]))
});
var stxDeployContractResultSchema = v6.object({
  /**
   * The ID of the transaction.
   */
  txid: v6.string(),
  /**
   * A Stacks transaction as a hex-encoded string.
   */
  transaction: v6.string()
});
var stxDeployContractRequestMessageSchema = v6.object({
  ...rpcRequestMessageSchema.entries,
  ...v6.object({
    method: v6.literal(stxDeployContractMethodName),
    params: stxDeployContractParamsSchema,
    id: v6.string()
  }).entries
});

// src/request/types/stxMethods/getAccounts.ts
import * as v8 from "valibot";

// src/request/types/walletMethods.ts
import * as v7 from "valibot";
var accountActionsSchema = v7.object({
  read: v7.optional(v7.boolean())
});
var walletActionsSchema = v7.object({
  readNetwork: v7.optional(v7.boolean())
});
var accountPermissionSchema = v7.object({
  type: v7.literal("account"),
  resourceId: v7.string(),
  clientId: v7.string(),
  actions: accountActionsSchema
});
var walletPermissionSchema = v7.object({
  type: v7.literal("wallet"),
  resourceId: v7.string(),
  clientId: v7.string(),
  actions: walletActionsSchema
});
var PermissionRequestParams = v7.variant("type", [
  v7.object({
    ...v7.omit(accountPermissionSchema, ["clientId"]).entries
  }),
  v7.object({
    ...v7.omit(walletPermissionSchema, ["clientId"]).entries
  })
]);
var permission = v7.variant("type", [accountPermissionSchema, walletPermissionSchema]);
var requestPermissionsMethodName = "wallet_requestPermissions";
var requestPermissionsParamsSchema = v7.nullish(v7.array(PermissionRequestParams));
var requestPermissionsResultSchema = v7.literal(true);
var requestPermissionsRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: v7.string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions";
var renouncePermissionsParamsSchema = v7.nullish(v7.null());
var renouncePermissionsResultSchema = v7.nullish(v7.null());
var renouncePermissionsRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: v7.string()
  }).entries
});
var disconnectMethodName = "wallet_disconnect";
var disconnectParamsSchema = v7.nullish(v7.null());
var disconnectResultSchema = v7.nullish(v7.null());
var disconnectRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(disconnectMethodName),
    params: disconnectParamsSchema,
    id: v7.string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType";
var getWalletTypeParamsSchema = v7.nullish(v7.null());
var getWalletTypeResultSchema = walletTypeSchema;
var getWalletTypeRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(getWalletTypeMethodName),
    params: getWalletTypeParamsSchema,
    id: v7.string()
  }).entries
});
var getCurrentPermissionsMethodName = "wallet_getCurrentPermissions";
var getCurrentPermissionsParamsSchema = v7.nullish(v7.null());
var getCurrentPermissionsResultSchema = v7.array(permission);
var getCurrentPermissionsRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(getCurrentPermissionsMethodName),
    params: getCurrentPermissionsParamsSchema,
    id: v7.string()
  }).entries
});
var getNetworkMethodName = "wallet_getNetwork";
var getNetworkParamsSchema = v7.nullish(v7.null());
var getNetworkResultSchema = v7.object({
  bitcoin: v7.object({
    name: v7.enum(BitcoinNetworkType)
  }),
  stacks: v7.object({
    name: v7.string()
  })
});
var getNetworkRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(getNetworkMethodName),
    params: getNetworkParamsSchema,
    id: v7.string()
  }).entries
});
var changeNetworkMethodName = "wallet_changeNetwork";
var changeNetworkParamsSchema = v7.object({
  name: v7.enum(BitcoinNetworkType)
});
var changeNetworkResultSchema = v7.nullish(v7.null());
var changeNetworkRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(changeNetworkMethodName),
    params: changeNetworkParamsSchema,
    id: v7.string()
  }).entries
});
var changeNetworkByIdMethodName = "wallet_changeNetworkById";
var changeNetworkByIdParamsSchema = v7.object({
  id: v7.string()
});
var changeNetworkByIdResultSchema = v7.nullish(v7.null());
var changeNetworkByIdRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(changeNetworkByIdMethodName),
    params: changeNetworkByIdParamsSchema,
    id: v7.string()
  }).entries
});
var getAccountMethodName = "wallet_getAccount";
var getAccountParamsSchema = v7.nullish(v7.null());
var getAccountResultSchema = v7.object({
  id: v7.string(),
  addresses: v7.array(addressSchema),
  walletType: walletTypeSchema,
  network: getNetworkResultSchema
});
var getAccountRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(getAccountMethodName),
    params: getAccountParamsSchema,
    id: v7.string()
  }).entries
});
var connectMethodName = "wallet_connect";
var connectParamsSchema = v7.nullish(
  v7.object({
    permissions: v7.optional(v7.array(PermissionRequestParams)),
    addresses: v7.optional(v7.array(v7.enum(AddressPurpose))),
    message: v7.optional(
      v7.pipe(v7.string(), v7.maxLength(80, "The message must not exceed 80 characters."))
    ),
    network: v7.optional(v7.enum(BitcoinNetworkType))
  })
);
var connectResultSchema = v7.object({
  id: v7.string(),
  addresses: v7.array(addressSchema),
  walletType: walletTypeSchema,
  network: getNetworkResultSchema
});
var connectRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(connectMethodName),
    params: connectParamsSchema,
    id: v7.string()
  }).entries
});
var addNetworkMethodName = "wallet_addNetwork";
var addNetworkParamsSchema = v7.variant("chain", [
  v7.object({
    chain: v7.literal("bitcoin"),
    type: v7.enum(BitcoinNetworkType),
    name: v7.string(),
    rpcUrl: v7.string(),
    rpcFallbackUrl: v7.optional(v7.string()),
    indexerUrl: v7.optional(v7.string()),
    blockExplorerUrl: v7.optional(v7.string()),
    switch: v7.optional(v7.boolean())
  }),
  v7.object({
    chain: v7.literal("stacks"),
    name: v7.string(),
    type: v7.enum(StacksNetworkType),
    rpcUrl: v7.string(),
    blockExplorerUrl: v7.optional(v7.string()),
    switch: v7.optional(v7.boolean())
  }),
  v7.object({
    chain: v7.literal("starknet"),
    name: v7.string(),
    type: v7.enum(StarknetNetworkType),
    rpcUrl: v7.string(),
    blockExplorerUrl: v7.optional(v7.string()),
    switch: v7.optional(v7.boolean())
  })
]);
var addNetworkRequestMessageSchema = v7.object({
  ...rpcRequestMessageSchema.entries,
  ...v7.object({
    method: v7.literal(addNetworkMethodName),
    params: addNetworkParamsSchema,
    id: v7.string()
  }).entries
});
var addNetworkResultSchema = v7.object({
  id: v7.string()
});

// src/request/types/stxMethods/getAccounts.ts
var stxGetAccountsMethodName = "stx_getAccounts";
var stxGetAccountsParamsSchema = v8.nullish(v8.null());
var stxGetAccountsResultSchema = v8.object({
  /**
   * The addresses generated for the given purposes.
   */
  addresses: v8.array(
    v8.object({
      address: v8.string(),
      publicKey: v8.string(),
      gaiaHubUrl: v8.string(),
      gaiaAppKey: v8.string()
    })
  ),
  network: getNetworkResultSchema
});
var stxGetAccountsRequestMessageSchema = v8.object({
  ...rpcRequestMessageSchema.entries,
  ...v8.object({
    method: v8.literal(stxGetAccountsMethodName),
    params: stxGetAccountsParamsSchema,
    id: v8.string()
  }).entries
});

// src/request/types/stxMethods/getAddresses.ts
import * as v9 from "valibot";
var stxGetAddressesMethodName = "stx_getAddresses";
var stxGetAddressesParamsSchema = v9.nullish(
  v9.object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: v9.optional(v9.string())
  })
);
var stxGetAddressesResultSchema = v9.object({
  /**
   * The addresses generated for the given purposes.
   */
  addresses: v9.array(addressSchema),
  network: getNetworkResultSchema
});
var stxGetAddressesRequestMessageSchema = v9.object({
  ...rpcRequestMessageSchema.entries,
  ...v9.object({
    method: v9.literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: v9.string()
  }).entries
});

// src/request/types/stxMethods/signMessage.ts
import * as v10 from "valibot";
var stxSignMessageMethodName = "stx_signMessage";
var stxSignMessageParamsSchema = v10.object({
  /**
   * The message to sign.
   */
  message: v10.string()
});
var stxSignMessageResultSchema = v10.object({
  /**
   * The signature of the message.
   */
  signature: v10.string(),
  /**
   * The public key used to sign the message.
   */
  publicKey: v10.string()
});
var stxSignMessageRequestMessageSchema = v10.object({
  ...rpcRequestMessageSchema.entries,
  ...v10.object({
    method: v10.literal(stxSignMessageMethodName),
    params: stxSignMessageParamsSchema,
    id: v10.string()
  }).entries
});

// src/request/types/stxMethods/signStructuredMessage.ts
import * as v11 from "valibot";
var stxSignStructuredMessageMethodName = "stx_signStructuredMessage";
var stxSignStructuredMessageParamsSchema = v11.object({
  /**
   * The domain to be signed.
   */
  domain: v11.string(),
  /**
   * Message payload to be signed.
   */
  message: v11.string(),
  /**
   * The public key to sign the message with.
   */
  publicKey: v11.optional(v11.string())
});
var stxSignStructuredMessageResultSchema = v11.object({
  /**
   * Signature of the message.
   */
  signature: v11.string(),
  /**
   * Public key as hex-encoded string.
   */
  publicKey: v11.string()
});
var stxSignStructuredMessageRequestMessageSchema = v11.object({
  ...rpcRequestMessageSchema.entries,
  ...v11.object({
    method: v11.literal(stxSignStructuredMessageMethodName),
    params: stxSignStructuredMessageParamsSchema,
    id: v11.string()
  }).entries
});

// src/request/types/stxMethods/signTransaction.ts
import * as v12 from "valibot";
var stxSignTransactionMethodName = "stx_signTransaction";
var stxSignTransactionParamsSchema = v12.object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: v12.string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: v12.optional(v12.string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: v12.optional(v12.boolean())
});
var stxSignTransactionResultSchema = v12.object({
  /**
   * The signed transaction as a hex-encoded string.
   */
  transaction: v12.string()
});
var stxSignTransactionRequestMessageSchema = v12.object({
  ...rpcRequestMessageSchema.entries,
  ...v12.object({
    method: v12.literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: v12.string()
  }).entries
});

// src/request/types/stxMethods/signTransactions.ts
import * as v13 from "valibot";
var stxSignTransactionsMethodName = "stx_signTransactions";
var stxSignTransactionsParamsSchema = v13.object({
  /**
   * The transactions to sign as hex-encoded strings.
   */
  transactions: v13.pipe(
    v13.array(
      v13.pipe(
        v13.string(),
        v13.check((hex) => {
          return true;
        }, "Invalid hex-encoded Stacks transaction.")
      )
    ),
    v13.minLength(1)
  ),
  /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */
  broadcast: v13.optional(v13.boolean())
});
var stxSignTransactionsResultSchema = v13.object({
  /**
   * The signed transactions as hex-encoded strings, in the same order as in the
   * sign request.
   */
  transactions: v13.array(v13.string())
});
var stxSignTransactionsRequestMessageSchema = v13.object({
  ...rpcRequestMessageSchema.entries,
  ...v13.object({
    method: v13.literal(stxSignTransactionsMethodName),
    params: stxSignTransactionsParamsSchema,
    id: v13.string()
  }).entries
});

// src/request/types/stxMethods/transferStx.ts
import * as v14 from "valibot";
var stxTransferStxMethodName = "stx_transferStx";
var stxTransferStxParamsSchema = v14.object({
  /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */
  amount: v14.union([v14.number(), v14.string()]),
  /**
   * The recipeint's principal.
   */
  recipient: v14.string(),
  /**
   * A string representing the memo.
   */
  memo: v14.optional(v14.string()),
  /**
   * Version of parameter format.
   */
  version: v14.optional(v14.string()),
  /**
   * The mode of the post conditions.
   */
  postConditionMode: v14.optional(v14.number()),
  /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */
  postConditions: v14.optional(v14.array(v14.string())),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: v14.optional(v14.string())
});
var stxTransferStxResultSchema = v14.object({
  /**
   * The ID of the transaction.
   */
  txid: v14.string(),
  /**
   * A Stacks transaction as a hex-encoded string.
   */
  transaction: v14.string()
});
var stxTransferStxRequestMessageSchema = v14.object({
  ...rpcRequestMessageSchema.entries,
  ...v14.object({
    method: v14.literal(stxTransferStxMethodName),
    params: stxTransferStxParamsSchema,
    id: v14.string()
  }).entries
});

// src/request/types/btcMethods.ts
import * as v15 from "valibot";
var getInfoMethodName = "getInfo";
var getInfoParamsSchema = v15.nullish(v15.null());
var getInfoResultSchema = v15.object({
  /**
   * Version of the wallet.
   */
  version: v15.string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: v15.optional(v15.array(v15.string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: v15.array(v15.string())
});
var getInfoRequestMessageSchema = v15.object({
  ...rpcRequestMessageSchema.entries,
  ...v15.object({
    method: v15.literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: v15.string()
  }).entries
});
var getAddressesMethodName = "getAddresses";
var getAddressesParamsSchema = v15.object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: v15.array(v15.enum(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: v15.optional(v15.string())
});
var getAddressesResultSchema = v15.object({
  /**
   * The addresses generated for the given purposes.
   */
  addresses: v15.array(addressSchema),
  network: getNetworkResultSchema
});
var getAddressesRequestMessageSchema = v15.object({
  ...rpcRequestMessageSchema.entries,
  ...v15.object({
    method: v15.literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: v15.string()
  }).entries
});
var signMessageMethodName = "signMessage";
var MessageSigningProtocols = /* @__PURE__ */ ((MessageSigningProtocols2) => {
  MessageSigningProtocols2["ECDSA"] = "ECDSA";
  MessageSigningProtocols2["BIP322"] = "BIP322";
  return MessageSigningProtocols2;
})(MessageSigningProtocols || {});
var signMessageParamsSchema = v15.object({
  /**
   * The address used for signing.
   **/
  address: v15.string(),
  /**
   * The message to sign.
   **/
  message: v15.string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: v15.optional(v15.enum(MessageSigningProtocols))
});
var signMessageResultSchema = v15.object({
  /**
   * The signature of the message.
   */
  signature: v15.string(),
  /**
   * hash of the message.
   */
  messageHash: v15.string(),
  /**
   * The address used for signing.
   */
  address: v15.string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: v15.enum(MessageSigningProtocols)
});
var signMessageRequestMessageSchema = v15.object({
  ...rpcRequestMessageSchema.entries,
  ...v15.object({
    method: v15.literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: v15.string()
  }).entries
});
var sendTransferMethodName = "sendTransfer";
var sendTransferParamsSchema = v15.object({
  /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */
  recipients: v15.array(
    v15.object({
      address: v15.string(),
      amount: v15.number()
    })
  )
});
var sendTransferResultSchema = v15.object({
  /**
   * The transaction id as a hex-encoded string.
   */
  txid: v15.string()
});
var sendTransferRequestMessageSchema = v15.object({
  ...rpcRequestMessageSchema.entries,
  ...v15.object({
    method: v15.literal(sendTransferMethodName),
    params: sendTransferParamsSchema,
    id: v15.string()
  }).entries
});
var signPsbtMethodName = "signPsbt";
var signPsbtParamsSchema = v15.object({
  /**
   * The base64 encoded PSBT to sign.
   */
  psbt: v15.string(),
  /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */
  signInputs: v15.optional(v15.record(v15.string(), v15.array(v15.number()))),
  /**
   * Whether to broadcast the transaction after signing.
   **/
  broadcast: v15.optional(v15.boolean())
});
var signPsbtResultSchema = v15.object({
  /**
   * The base64 encoded PSBT after signing.
   */
  psbt: v15.string(),
  /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/
  txid: v15.optional(v15.string())
});
var signPsbtRequestMessageSchema = v15.object({
  ...rpcRequestMessageSchema.entries,
  ...v15.object({
    method: v15.literal(signPsbtMethodName),
    params: signPsbtParamsSchema,
    id: v15.string()
  }).entries
});
var getAccountsMethodName = "getAccounts";
var getAccountsParamsSchema = v15.object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: v15.array(v15.enum(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: v15.optional(v15.string())
});
var getAccountsResultSchema = v15.array(
  v15.object({
    ...addressSchema.entries,
    ...v15.object({
      walletType: walletTypeSchema
    }).entries
  })
);
var getAccountsRequestMessageSchema = v15.object({
  ...rpcRequestMessageSchema.entries,
  ...v15.object({
    method: v15.literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: v15.string()
  }).entries
});
var getBalanceMethodName = "getBalance";
var getBalanceParamsSchema = v15.nullish(v15.null());
var getBalanceResultSchema = v15.object({
  /**
   * The confirmed balance of the wallet in sats. Using a string due to chrome
   * messages not supporting bigint
   * (https://issues.chromium.org/issues/40116184).
   */
  confirmed: v15.string(),
  /**
   * The unconfirmed balance of the wallet in sats. Using a string due to chrome
   * messages not supporting bigint
   * (https://issues.chromium.org/issues/40116184).
   */
  unconfirmed: v15.string(),
  /**
   * The total balance (both confirmed and unconfrimed UTXOs) of the wallet in
   * sats. Using a string due to chrome messages not supporting bigint
   * (https://issues.chromium.org/issues/40116184).
   */
  total: v15.string()
});
var getBalanceRequestMessageSchema = v15.object({
  ...rpcRequestMessageSchema.entries,
  ...v15.object({
    method: v15.literal(getBalanceMethodName),
    id: v15.string()
  }).entries
});

// src/request/types/runesMethods/etch.ts
import * as v16 from "valibot";
var runesEtchMethodName = "runes_etch";
var etchTermsSchema = v16.object({
  amount: v16.string(),
  cap: v16.string(),
  heightStart: v16.optional(v16.string()),
  heightEnd: v16.optional(v16.string()),
  offsetStart: v16.optional(v16.string()),
  offsetEnd: v16.optional(v16.string())
});
var inscriptionDetailsSchema = v16.object({
  contentType: v16.string(),
  contentBase64: v16.string()
});
var runesEtchParamsSchema = v16.object({
  runeName: v16.string(),
  divisibility: v16.optional(v16.number()),
  symbol: v16.optional(v16.string()),
  premine: v16.optional(v16.string()),
  isMintable: v16.boolean(),
  delegateInscriptionId: v16.optional(v16.string()),
  destinationAddress: v16.string(),
  refundAddress: v16.string(),
  feeRate: v16.number(),
  appServiceFee: v16.optional(v16.number()),
  appServiceFeeAddress: v16.optional(v16.string()),
  terms: v16.optional(etchTermsSchema),
  inscriptionDetails: v16.optional(inscriptionDetailsSchema),
  network: v16.optional(v16.enum(BitcoinNetworkType))
});
var runesEtchResultSchema = v16.object({
  orderId: v16.string(),
  fundTransactionId: v16.string(),
  fundingAddress: v16.string()
});
var runesEtchRequestMessageSchema = v16.object({
  ...rpcRequestMessageSchema.entries,
  ...v16.object({
    method: v16.literal(runesEtchMethodName),
    params: runesEtchParamsSchema,
    id: v16.string()
  }).entries
});

// src/request/types/runesMethods/getBalance.ts
import * as v17 from "valibot";
var runesGetBalanceMethodName = "runes_getBalance";
var runesGetBalanceParamsSchema = v17.nullish(v17.null());
var runesGetBalanceResultSchema = v17.object({
  balances: v17.array(
    v17.object({
      runeName: v17.string(),
      amount: v17.string(),
      divisibility: v17.number(),
      symbol: v17.string(),
      inscriptionId: v17.nullish(v17.string()),
      spendableBalance: v17.string()
    })
  )
});
var runesGetBalanceRequestMessageSchema = v17.object({
  ...rpcRequestMessageSchema.entries,
  ...v17.object({
    method: v17.literal(runesGetBalanceMethodName),
    params: runesGetBalanceParamsSchema,
    id: v17.string()
  }).entries
});

// src/request/types/runesMethods/mint.ts
import * as v18 from "valibot";
var runesMintMethodName = "runes_mint";
var runesMintParamsSchema = v18.object({
  appServiceFee: v18.optional(v18.number()),
  appServiceFeeAddress: v18.optional(v18.string()),
  destinationAddress: v18.string(),
  feeRate: v18.number(),
  refundAddress: v18.string(),
  repeats: v18.number(),
  runeName: v18.string(),
  network: v18.optional(v18.enum(BitcoinNetworkType))
});
var runesMintResultSchema = v18.object({
  orderId: v18.string(),
  fundTransactionId: v18.string(),
  fundingAddress: v18.string()
});
var runesMintRequestMessageSchema = v18.object({
  ...rpcRequestMessageSchema.entries,
  ...v18.object({
    method: v18.literal(runesMintMethodName),
    params: runesMintParamsSchema,
    id: v18.string()
  }).entries
});

// src/request/types/runesMethods/transfer.ts
import * as v19 from "valibot";
var runesTransferMethodName = "runes_transfer";
var runesTransferParamsSchema = v19.object({
  recipients: v19.array(
    v19.object({
      runeName: v19.string(),
      amount: v19.string(),
      address: v19.string()
    })
  )
});
var runesTransferResultSchema = v19.object({
  txid: v19.string()
});
var runesTransferRequestMessageSchema = v19.object({
  ...rpcRequestMessageSchema.entries,
  ...v19.object({
    method: v19.literal(runesTransferMethodName),
    params: runesTransferParamsSchema,
    id: v19.string()
  }).entries
});

// src/request/types/ordinalsMethods.ts
import * as v20 from "valibot";
var getInscriptionsMethodName = "ord_getInscriptions";
var getInscriptionsParamsSchema = v20.object({
  offset: v20.number(),
  limit: v20.number()
});
var getInscriptionsResultSchema = v20.object({
  total: v20.number(),
  limit: v20.number(),
  offset: v20.number(),
  inscriptions: v20.array(
    v20.object({
      inscriptionId: v20.string(),
      inscriptionNumber: v20.string(),
      address: v20.string(),
      collectionName: v20.optional(v20.string()),
      postage: v20.string(),
      contentLength: v20.string(),
      contentType: v20.string(),
      timestamp: v20.number(),
      offset: v20.number(),
      genesisTransaction: v20.string(),
      output: v20.string()
    })
  )
});
var getInscriptionsRequestMessageSchema = v20.object({
  ...rpcRequestMessageSchema.entries,
  ...v20.object({
    method: v20.literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: v20.string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions";
var sendInscriptionsParamsSchema = v20.object({
  transfers: v20.array(
    v20.object({
      address: v20.string(),
      inscriptionId: v20.string()
    })
  )
});
var sendInscriptionsResultSchema = v20.object({
  txid: v20.string()
});
var sendInscriptionsRequestMessageSchema = v20.object({
  ...rpcRequestMessageSchema.entries,
  ...v20.object({
    method: v20.literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: v20.string()
  }).entries
});

// src/request/index.ts
var request = async (method, params, providerId) => {
  let provider = window.XverseProviders?.BitcoinProvider || window.BitcoinProvider;
  if (providerId) {
    provider = await getProviderById(providerId);
  }
  if (!provider) {
    throw new Error("no wallet provider was found");
  }
  if (!method) {
    throw new Error("A wallet method is required");
  }
  const response = await provider.request(method, params);
  if (v21.is(rpcErrorResponseMessageSchema, response)) {
    return {
      status: "error",
      error: response.error
    };
  }
  if (v21.is(rpcSuccessResponseMessageSchema, response)) {
    return {
      status: "success",
      result: response.result
    };
  }
  return {
    status: "error",
    error: {
      code: -32603 /* INTERNAL_ERROR */,
      message: "Received unknown response from provider.",
      data: response
    }
  };
};
var addListener = (event, cb, providerId) => {
  let provider = window.XverseProviders?.BitcoinProvider || window.BitcoinProvider;
  if (providerId) {
    provider = getProviderById(providerId);
  }
  if (!provider) {
    throw new Error("no wallet provider was found");
  }
  if (!provider.addListener) {
    console.error(
      `The wallet provider you are using does not support the addListener method. Please update your wallet provider.`
    );
    return () => {
    };
  }
  return provider.addListener(event, cb);
};

// src/runes/api.ts
import axios from "axios";
var urlNetworkSuffix = {
  ["Mainnet" /* Mainnet */]: "",
  ["Testnet" /* Testnet */]: "-testnet",
  ["Testnet4" /* Testnet4 */]: "-testnet4",
  ["Signet" /* Signet */]: "-signet"
};
var ORDINALS_API_BASE_URL = (network = "Mainnet" /* Mainnet */) => {
  if (network === "Regtest" /* Regtest */) {
    throw new Error(`Ordinals API does not support ${network} network`);
  }
  return `https://ordinals${urlNetworkSuffix[network]}.xverse.app/v1`;
};
var RunesApi = class {
  client;
  constructor(network) {
    this.client = axios.create({
      baseURL: ORDINALS_API_BASE_URL(network)
    });
  }
  parseError = (error) => {
    return {
      code: error.response?.status,
      message: JSON.stringify(error.response?.data)
    };
  };
  estimateMintCost = async (mintParams) => {
    try {
      const response = await this.client.post("/runes/mint/estimate", {
        ...mintParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  estimateEtchCost = async (etchParams) => {
    try {
      const response = await this.client.post("/runes/etch/estimate", {
        ...etchParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  createMintOrder = async (mintOrderParams) => {
    try {
      const response = await this.client.post("/runes/mint/orders", {
        ...mintOrderParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  createEtchOrder = async (etchOrderParams) => {
    try {
      const response = await this.client.post("/runes/etch/orders", {
        ...etchOrderParams
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  executeMint = async (orderId, fundTransactionId) => {
    try {
      const response = await this.client.post(`/runes/mint/orders/${orderId}/execute`, {
        fundTransactionId
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  executeEtch = async (orderId, fundTransactionId) => {
    try {
      const response = await this.client.post(`/runes/etch/orders/${orderId}/execute`, {
        fundTransactionId
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  getOrder = async (orderId) => {
    try {
      const response = await this.client.get(`/orders/${orderId}`);
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
  rbfOrder = async (rbfRequest) => {
    const { orderId, newFeeRate } = rbfRequest;
    try {
      const response = await this.client.post(`/orders/${orderId}/rbf-estimate`, {
        newFeeRate
      });
      return {
        data: response.data
      };
    } catch (error) {
      const err = error;
      return {
        error: this.parseError(err)
      };
    }
  };
};
var clients = {};
var getRunesApiClient = (network = "Mainnet" /* Mainnet */) => {
  if (!clients[network]) {
    clients[network] = new RunesApi(network);
  }
  return clients[network];
};

// src/adapters/satsConnectAdapter.ts
var SatsConnectAdapter = class {
  async mintRunes(params) {
    try {
      const walletInfo = await this.requestInternal("getInfo", null).catch(() => null);
      if (walletInfo && walletInfo.status === "success") {
        const isMintSupported = walletInfo.result.methods?.includes("runes_mint");
        if (isMintSupported) {
          const response = await this.requestInternal("runes_mint", params);
          if (response) {
            if (response.status === "success") {
              return response;
            }
            if (response.status === "error" && response.error.code !== -32601 /* METHOD_NOT_FOUND */) {
              return response;
            }
          }
        }
      }
      const mintRequest = {
        destinationAddress: params.destinationAddress,
        feeRate: params.feeRate,
        refundAddress: params.refundAddress,
        repeats: params.repeats,
        runeName: params.runeName,
        appServiceFee: params.appServiceFee,
        appServiceFeeAddress: params.appServiceFeeAddress
      };
      const orderResponse = await new RunesApi(params.network).createMintOrder(mintRequest);
      if (!orderResponse.data) {
        return {
          status: "error",
          error: {
            code: orderResponse.error.code === 400 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
            message: orderResponse.error.message
          }
        };
      }
      const paymentResponse = await this.requestInternal("sendTransfer", {
        recipients: [
          {
            address: orderResponse.data.fundAddress,
            amount: orderResponse.data.fundAmount
          }
        ]
      });
      if (paymentResponse.status !== "success") {
        return paymentResponse;
      }
      await new RunesApi(params.network).executeMint(
        orderResponse.data.orderId,
        paymentResponse.result.txid
      );
      return {
        status: "success",
        result: {
          orderId: orderResponse.data.orderId,
          fundTransactionId: paymentResponse.result.txid,
          fundingAddress: orderResponse.data.fundAddress
        }
      };
    } catch (error) {
      return {
        status: "error",
        error: {
          code: -32603 /* INTERNAL_ERROR */,
          message: error.message
        }
      };
    }
  }
  async etchRunes(params) {
    const etchRequest = {
      destinationAddress: params.destinationAddress,
      refundAddress: params.refundAddress,
      feeRate: params.feeRate,
      runeName: params.runeName,
      divisibility: params.divisibility,
      symbol: params.symbol,
      premine: params.premine,
      isMintable: params.isMintable,
      terms: params.terms,
      inscriptionDetails: params.inscriptionDetails,
      delegateInscriptionId: params.delegateInscriptionId,
      appServiceFee: params.appServiceFee,
      appServiceFeeAddress: params.appServiceFeeAddress
    };
    try {
      const walletInfo = await this.requestInternal("getInfo", null).catch(() => null);
      if (walletInfo && walletInfo.status === "success") {
        const isEtchSupported = walletInfo.result.methods?.includes("runes_etch");
        if (isEtchSupported) {
          const response = await this.requestInternal("runes_etch", params);
          if (response) {
            if (response.status === "success") {
              return response;
            }
            if (response.status === "error" && response.error.code !== -32601 /* METHOD_NOT_FOUND */) {
              return response;
            }
          }
        }
      }
      const orderResponse = await new RunesApi(params.network).createEtchOrder(etchRequest);
      if (!orderResponse.data) {
        return {
          status: "error",
          error: {
            code: orderResponse.error.code === 400 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
            message: orderResponse.error.message
          }
        };
      }
      const paymentResponse = await this.requestInternal("sendTransfer", {
        recipients: [
          {
            address: orderResponse.data.fundAddress,
            amount: orderResponse.data.fundAmount
          }
        ]
      });
      if (paymentResponse.status !== "success") {
        return paymentResponse;
      }
      await new RunesApi(params.network).executeEtch(
        orderResponse.data.orderId,
        paymentResponse.result.txid
      );
      return {
        status: "success",
        result: {
          orderId: orderResponse.data.orderId,
          fundTransactionId: paymentResponse.result.txid,
          fundingAddress: orderResponse.data.fundAddress
        }
      };
    } catch (error) {
      return {
        status: "error",
        error: {
          code: -32603 /* INTERNAL_ERROR */,
          message: error.message
        }
      };
    }
  }
  async estimateMint(params) {
    const estimateMintRequest = {
      destinationAddress: params.destinationAddress,
      feeRate: params.feeRate,
      repeats: params.repeats,
      runeName: params.runeName,
      appServiceFee: params.appServiceFee,
      appServiceFeeAddress: params.appServiceFeeAddress
    };
    const response = await getRunesApiClient(
      params.network
    ).estimateMintCost(estimateMintRequest);
    if (response.data) {
      return {
        status: "success",
        result: response.data
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
        message: response.error.message
      }
    };
  }
  async estimateEtch(params) {
    const estimateEtchRequest = {
      destinationAddress: params.destinationAddress,
      feeRate: params.feeRate,
      runeName: params.runeName,
      divisibility: params.divisibility,
      symbol: params.symbol,
      premine: params.premine,
      isMintable: params.isMintable,
      terms: params.terms,
      inscriptionDetails: params.inscriptionDetails,
      delegateInscriptionId: params.delegateInscriptionId,
      appServiceFee: params.appServiceFee,
      appServiceFeeAddress: params.appServiceFeeAddress
    };
    const response = await getRunesApiClient(params.network).estimateEtchCost(estimateEtchRequest);
    if (response.data) {
      return {
        status: "success",
        result: response.data
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
        message: response.error.message
      }
    };
  }
  async getOrder(params) {
    const response = await getRunesApiClient(params.network).getOrder(params.id);
    if (response.data) {
      return {
        status: "success",
        result: response.data
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 || response.error.code === 404 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
        message: response.error.message
      }
    };
  }
  async estimateRbfOrder(params) {
    const rbfOrderRequest = {
      newFeeRate: params.newFeeRate,
      orderId: params.orderId
    };
    const response = await getRunesApiClient(params.network).rbfOrder(rbfOrderRequest);
    if (response.data) {
      return {
        status: "success",
        result: {
          fundingAddress: response.data.fundingAddress,
          rbfCost: response.data.rbfCost
        }
      };
    }
    return {
      status: "error",
      error: {
        code: response.error.code === 400 || response.error.code === 404 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
        message: response.error.message
      }
    };
  }
  async rbfOrder(params) {
    try {
      const rbfOrderRequest = {
        newFeeRate: params.newFeeRate,
        orderId: params.orderId
      };
      const orderResponse = await getRunesApiClient(params.network).rbfOrder(rbfOrderRequest);
      if (!orderResponse.data) {
        return {
          status: "error",
          error: {
            code: orderResponse.error.code === 400 || orderResponse.error.code === 404 ? -32600 /* INVALID_REQUEST */ : -32603 /* INTERNAL_ERROR */,
            message: orderResponse.error.message
          }
        };
      }
      const paymentResponse = await this.requestInternal("sendTransfer", {
        recipients: [
          {
            address: orderResponse.data.fundingAddress,
            amount: orderResponse.data.rbfCost
          }
        ]
      });
      if (paymentResponse.status !== "success") {
        return paymentResponse;
      }
      return {
        status: "success",
        result: {
          fundingAddress: orderResponse.data.fundingAddress,
          orderId: rbfOrderRequest.orderId,
          fundRBFTransactionId: paymentResponse.result.txid
        }
      };
    } catch (error) {
      return {
        status: "error",
        error: {
          code: -32603 /* INTERNAL_ERROR */,
          message: error.message
        }
      };
    }
  }
  async request(method, params) {
    switch (method) {
      case "runes_mint":
        return this.mintRunes(params);
      case "runes_etch":
        return this.etchRunes(params);
      case "runes_estimateMint":
        return this.estimateMint(params);
      case "runes_estimateEtch":
        return this.estimateEtch(params);
      case "runes_getOrder": {
        return this.getOrder(params);
      }
      case "runes_estimateRbfOrder": {
        return this.estimateRbfOrder(params);
      }
      case "runes_rbfOrder": {
        return this.rbfOrder(params);
      }
      default:
        return this.requestInternal(method, params);
    }
  }
};

// src/adapters/xverse.ts
var XverseAdapter = class extends SatsConnectAdapter {
  id = DefaultAdaptersInfo.xverse.id;
  requestInternal = async (method, params) => {
    return request(method, params, this.id);
  };
  addListener = (event, cb) => {
    return addListener(
      event,
      // The types of the `addListener` function being called here are not
      // entirely accurate.
      cb,
      this.id
    );
  };
};

// src/adapters/unisat.ts
import { AddressType as AddressType2, getAddressInfo } from "bitcoin-address-validation";
import { Buffer } from "buffer";
function convertSignInputsToInputType(signInputs) {
  let result = [];
  if (!signInputs) {
    return result;
  }
  for (let address in signInputs) {
    let indexes = signInputs[address];
    for (let index of indexes) {
      result.push({
        index,
        address
      });
    }
  }
  return result;
}
var UnisatAdapter = class extends SatsConnectAdapter {
  id = DefaultAdaptersInfo.unisat.id;
  async getAccounts(params) {
    const { purposes } = params;
    if (purposes.includes("stacks" /* Stacks */)) {
      throw new Error("Only bitcoin addresses are supported");
    }
    const accounts = await window.unisat.requestAccounts();
    const publicKey = await window.unisat.getPublicKey();
    const address = accounts[0];
    const addressType = getAddressInfo(accounts[0]).type;
    const pk = addressType === AddressType2.p2tr ? publicKey.slice(2) : publicKey;
    const paymentAddress = {
      address,
      publicKey: pk,
      addressType,
      purpose: "payment" /* Payment */,
      walletType: "software"
    };
    const ordinalsAddress = {
      address,
      publicKey: pk,
      addressType,
      purpose: "ordinals" /* Ordinals */,
      walletType: "software"
    };
    const response = [];
    if (purposes.includes("payment" /* Payment */)) {
      response.push({ ...paymentAddress, walletType: "software" });
    }
    if (purposes.includes("ordinals" /* Ordinals */)) {
      response.push({ ...ordinalsAddress, walletType: "software" });
    }
    return response;
  }
  async signMessage(params) {
    const { message, address } = params;
    const addressType = getAddressInfo(address).type;
    const Bip322supportedTypes = [AddressType2.p2wpkh, AddressType2.p2tr];
    if (Bip322supportedTypes.includes(addressType)) {
      const response2 = await window.unisat.signMessage(message, "bip322-simple");
      return {
        address,
        messageHash: "",
        signature: response2,
        protocol: "BIP322" /* BIP322 */
      };
    }
    const response = await window.unisat.signMessage(message, "ecdsa");
    return {
      address,
      messageHash: "",
      signature: response,
      protocol: "ECDSA" /* ECDSA */
    };
  }
  async sendTransfer(params) {
    const { recipients } = params;
    if (recipients.length > 1) {
      throw new Error("Only one recipient is supported by this wallet provider");
    }
    const txid = await window.unisat.sendBitcoin(recipients[0].address, recipients[0].amount);
    return {
      txid
    };
  }
  async signPsbt(params) {
    const { psbt, signInputs, broadcast } = params;
    const psbtHex = Buffer.from(psbt, "base64").toString("hex");
    const signedPsbt = await window.unisat.signPsbt(psbtHex, {
      autoFinalized: broadcast,
      toSignInputs: convertSignInputsToInputType(signInputs)
    });
    const signedPsbtBase64 = Buffer.from(signedPsbt, "hex").toString("base64");
    let txid;
    if (broadcast) {
      txid = await window.unisat.pushPsbt(signedPsbt);
    }
    return {
      psbt: signedPsbtBase64,
      txid
    };
  }
  requestInternal = async (method, params) => {
    try {
      switch (method) {
        case "getAccounts": {
          const response = await this.getAccounts(
            params
          );
          return {
            status: "success",
            result: response
          };
        }
        case "sendTransfer": {
          const response = await this.sendTransfer(params);
          return {
            status: "success",
            result: response
          };
        }
        case "signMessage": {
          const response = await this.signMessage(params);
          return {
            status: "success",
            result: response
          };
        }
        case "signPsbt": {
          const response = await this.signPsbt(params);
          return {
            status: "success",
            result: response
          };
        }
        default: {
          const error = {
            code: -32001 /* METHOD_NOT_SUPPORTED */,
            message: "Method not supported by the selected wallet"
          };
          console.error("Error calling the method", error);
          return {
            status: "error",
            error
          };
        }
      }
    } catch (error) {
      console.error("Error calling the method", error);
      return {
        status: "error",
        error: {
          code: error.code === 4001 ? -32e3 /* USER_REJECTION */ : -32603 /* INTERNAL_ERROR */,
          message: error.message ? error.message : "Wallet method call error",
          data: error
        }
      };
    }
  };
  addListener = (eventName, cb) => {
    switch (eventName) {
      case "accountChange": {
        const handler = () => {
          cb({ type: "accountChange" });
        };
        window.unisat.on("accountsChanged", handler);
        return () => {
          window.unisat.removeListener("accountsChanged", handler);
        };
      }
      case "networkChange": {
        const handler = () => {
          cb({ type: "networkChange" });
        };
        window.unisat.on("networkChanged", handler);
        return () => {
          window.unisat.removeListener("networkChanged", handler);
        };
      }
      default: {
        console.error("Event not supported by the selected wallet");
        return () => {
        };
      }
    }
  };
};

// src/adapters/fordefi.ts
var FordefiAdapter = class extends SatsConnectAdapter {
  id = DefaultAdaptersInfo.fordefi.id;
  requestInternal = async (method, params) => {
    const provider = getProviderById(this.id);
    if (!provider) {
      throw new Error("no wallet provider was found");
    }
    if (!method) {
      throw new Error("A wallet method is required");
    }
    return await provider.request(method, params);
  };
  addListener = (eventName, cb) => {
    const provider = getProviderById(this.id);
    if (!provider) {
      throw new Error("no wallet provider was found");
    }
    if (!provider.addListener) {
      console.error(
        `The wallet provider you are using does not support the addListener method. Please update your wallet provider.`
      );
      return () => {
      };
    }
    return provider.addListener(
      eventName,
      cb
    );
  };
};

// src/adapters/BaseAdapter.ts
var BaseAdapter = class extends SatsConnectAdapter {
  id = "";
  constructor(providerId) {
    super();
    this.id = providerId;
  }
  requestInternal = async (method, params) => {
    return request(method, params, this.id);
  };
  addListener = (..._args) => {
    throw new Error("Method not supported for `BaseAdapter`.");
  };
};

// src/adapters/index.ts
var DefaultAdaptersInfo = {
  fordefi: {
    id: "FordefiProviders.UtxoProvider",
    name: "Fordefi",
    webUrl: "https://www.fordefi.com/",
    chromeWebStoreUrl: "https://chromewebstore.google.com/detail/fordefi/hcmehenccjdmfbojapcbcofkgdpbnlle",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzNDk0XzY2MjU0KSI+CjxwYXRoIGQ9Ik0xMC44NzY5IDE1LjYzNzhIMS41VjE4LjM5OUMxLjUgMTkuODAxMyAyLjYzNDQ3IDIwLjkzOCA0LjAzMzkyIDIwLjkzOEg4LjI0OTkyTDEwLjg3NjkgMTUuNjM3OFoiIGZpbGw9IiM3OTk0RkYiLz4KPHBhdGggZD0iTTEuNSA5Ljc3NTUxSDE5LjA1MTZMMTcuMDEzOSAxMy44NzExSDEuNVY5Ljc3NTUxWiIgZmlsbD0iIzQ4NkRGRiIvPgo8cGF0aCBkPSJNNy42NTk5NiAzSDEuNTI0NDFWOC4wMDcwNEgyMi40NjEyVjNIMTYuMzI1NlY2LjczOTQ0SDE1LjA2MDZWM0g4LjkyNTAyVjYuNzM5NDRINy42NTk5NlYzWiIgZmlsbD0iIzVDRDFGQSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzNDk0XzY2MjU0Ij4KPHJlY3Qgd2lkdGg9IjIxIiBoZWlnaHQ9IjE4IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS41IDMpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg=="
  },
  xverse: {
    id: "XverseProviders.BitcoinProvider",
    name: "Xverse",
    webUrl: "https://www.xverse.app/",
    googlePlayStoreUrl: "https://play.google.com/store/apps/details?id=com.secretkeylabs.xverse",
    iOSAppStoreUrl: "https://apps.apple.com/app/xverse-bitcoin-web3-wallet/id1552272513",
    chromeWebStoreUrl: "https://chromewebstore.google.com/detail/xverse-wallet/idnnbdplmphpflfnlkomgpfbpcgelopg",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyIiBoZWlnaHQ9IjEwMiIgdmlld0JveD0iMCAwIDEwMiAxMDIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGlkPSJJY29uX0FydCAoRWRpdCBNZSkiPgo8cmVjdCB3aWR0aD0iMTAyIiBoZWlnaHQ9IjEwMiIgZmlsbD0iIzE4MTgxOCIvPgo8ZyBpZD0iTG9nby9FbWJsZW0iIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8yMF8xMjIzKSI+CjxwYXRoIGlkPSJWZWN0b3IiIGQ9Ik03NC42NTQyIDczLjg4ODNWNjUuMjMxMkM3NC42NTQyIDY0Ljg4OCA3NC41MTc3IDY0LjU2MDYgNzQuMjc0NSA2NC4zMTc0TDM3LjQzOTcgMjcuNDgyNUMzNy4xOTY1IDI3LjIzOTIgMzYuODY5MSAyNy4xMDI4IDM2LjUyNTggMjcuMTAyOEgyNy44NjlDMjcuNDQxNiAyNy4xMDI4IDI3LjA5MzggMjcuNDUwNiAyNy4wOTM4IDI3Ljg3OFYzNS45MjExQzI3LjA5MzggMzYuMjY0NCAyNy4yMzAyIDM2LjU5MTcgMjcuNDczNCAzNi44MzVMNDAuNjk1MiA1MC4wNTY3QzQwLjk5NzUgNTAuMzU5MSA0MC45OTc1IDUwLjg1MDEgNDAuNjk1MiA1MS4xNTI0TDI3LjMyMTEgNjQuNTI2NUMyNy4xNzU2IDY0LjY3MiAyNy4wOTM4IDY0Ljg2OTggMjcuMDkzOCA2NS4wNzQ0VjczLjg4ODNDMjcuMDkzOCA3NC4zMTUzIDI3LjQ0MTYgNzQuNjYzNSAyNy44NjkgNzQuNjYzNUg0Mi4zMzQyQzQyLjc2MTYgNzQuNjYzNSA0My4xMDk0IDc0LjMxNTMgNDMuMTA5NCA3My44ODgzVjY4LjY5NThDNDMuMTA5NCA2OC40OTEyIDQzLjE5MTIgNjguMjkzNSA0My4zMzY4IDY4LjE0NzlMNTAuNTExNCA2MC45NzMzQzUwLjgxMzggNjAuNjcwOSA1MS4zMDQ4IDYwLjY3MDkgNTEuNjA3MiA2MC45NzMzTDY0LjkxOTggNzQuMjg2MUM2NS4xNjMxIDc0LjUyOTMgNjUuNDkwNCA3NC42NjU4IDY1LjgzMzcgNzQuNjY1OEg3My44NzY3Qzc0LjMwNDIgNzQuNjY1OCA3NC42NTE5IDc0LjMxNzYgNzQuNjUxOSA3My44OTA2TDc0LjY1NDIgNzMuODg4M1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGlkPSJWZWN0b3JfMiIgZD0iTTU1LjM1OCAzOC41NjcySDYyLjYwMzFDNjMuMDMyOCAzOC41NjcyIDYzLjM4MjkgMzguOTE3MyA2My4zODI5IDM5LjM0NjlWNDYuNTkyMUM2My4zODI5IDQ3LjI4NzcgNjQuMjI0IDQ3LjYzNTUgNjQuNzE1MSA0Ny4xNDIyTDc0LjY1NDEgMzcuMTg3M0M3NC43OTk0IDM3LjA0MTggNzQuODgxNiAzNi44NDQgNzQuODgxNiAzNi42MzcxVjI3LjkxODlDNzQuODgxNiAyNy40ODkyIDc0LjUzMzQgMjcuMTM5MSA3NC4xMDE3IDI3LjEzOTFMNjUuMjUzOCAyNy4xMjc3QzY1LjA0NyAyNy4xMjc3IDY0Ljg0OTIgMjcuMjA5NiA2NC43MDE0IDI3LjM1NTFMNTQuODA1NiAzNy4yMzVDNTQuMzE0NSAzNy43MjYgNTQuNjYyMyAzOC41NjcyIDU1LjM1NTcgMzguNTY3Mkg1NS4zNThaIiBmaWxsPSIjRUU3QTMwIi8+CjwvZz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8yMF8xMjIzIj4KPHJlY3Qgd2lkdGg9IjQ3LjgxMjUiIGhlaWdodD0iNDcuODEyNSIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI3LjA5MzggMjcuMDkzOCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K"
  },
  unisat: {
    id: "unisat",
    name: "Unisat",
    webUrl: "https://unisat.io/",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE4MCAxODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMTAwNTBfNDE3MSkiPgo8cGF0aCBkPSJNMTEzLjY2IDI5LjI4OTdMMTQzLjk3IDU5LjMwOTdDMTQ2LjU1IDYxLjg1OTcgMTQ3LjgyIDY0LjQzOTcgMTQ3Ljc4IDY3LjAzOTdDMTQ3Ljc0IDY5LjYzOTcgMTQ2LjYzIDcyLjAwOTcgMTQ0LjQ2IDc0LjE1OTdDMTQyLjE5IDc2LjQwOTcgMTM5Ljc0IDc3LjU0OTcgMTM3LjEyIDc3LjU5OTdDMTM0LjUgNzcuNjM5NyAxMzEuOSA3Ni4zNzk3IDEyOS4zMiA3My44Mjk3TDk4LjMxOTkgNDMuMTI5N0M5NC43OTk5IDM5LjYzOTcgOTEuMzk5OSAzNy4xNjk3IDg4LjEyOTkgMzUuNzE5N0M4NC44NTk5IDM0LjI2OTcgODEuNDE5OSAzNC4wMzk3IDc3LjgxOTkgMzUuMDM5N0M3NC4yMDk5IDM2LjAyOTcgNzAuMzM5OSAzOC41Nzk3IDY2LjE4OTkgNDIuNjc5N0M2MC40Njk5IDQ4LjM0OTcgNTcuNzM5OSA1My42Njk3IDU4LjAxOTkgNTguNjM5N0M1OC4yOTk5IDYzLjYwOTcgNjEuMTM5OSA2OC43Njk3IDY2LjUyOTkgNzQuMDk5N0w5Ny43Nzk5IDEwNS4wNkMxMDAuMzkgMTA3LjY0IDEwMS42NyAxMTAuMjIgMTAxLjYzIDExMi43OEMxMDEuNTkgMTE1LjM1IDEwMC40NyAxMTcuNzIgOTguMjU5OSAxMTkuOTFDOTYuMDU5OSAxMjIuMDkgOTMuNjI5OSAxMjMuMjMgOTAuOTg5OSAxMjMuMzJDODguMzQ5OSAxMjMuNDEgODUuNzE5OSAxMjIuMTYgODMuMTE5OSAxMTkuNThMNTIuODA5OSA4OS41NTk3QzQ3Ljg3OTkgODQuNjc5NyA0NC4zMTk5IDgwLjA1OTcgNDIuMTI5OSA3NS42OTk3QzM5LjkzOTkgNzEuMzM5NyAzOS4xMTk5IDY2LjQwOTcgMzkuNjg5OSA2MC45MDk3QzQwLjE5OTkgNTYuMTk5NyA0MS43MDk5IDUxLjYzOTcgNDQuMjI5OSA0Ny4yMTk3QzQ2LjczOTkgNDIuNzk5NyA1MC4zMzk5IDM4LjI3OTcgNTUuMDA5OSAzMy42NDk3QzYwLjU2OTkgMjguMTM5NyA2NS44Nzk5IDIzLjkxOTcgNzAuOTM5OSAyMC45Nzk3Qzc1Ljk4OTkgMTguMDM5NyA4MC44Nzk5IDE2LjQwOTcgODUuNTk5OSAxNi4wNjk3QzkwLjMyOTkgMTUuNzI5NyA5NC45ODk5IDE2LjY2OTcgOTkuNTk5OSAxOC44ODk3QzEwNC4yMSAyMS4xMDk3IDEwOC44OSAyNC41Njk3IDExMy42NSAyOS4yODk3SDExMy42NloiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xMDA1MF80MTcxKSIvPgo8cGF0aCBkPSJNNjYuMTA5OSAxNTAuNDJMMzUuODA5OSAxMjAuNEMzMy4yMjk5IDExNy44NCAzMS45NTk5IDExNS4yNyAzMS45OTk5IDExMi42N0MzMi4wMzk5IDExMC4wNyAzMy4xNDk5IDEwNy43IDM1LjMxOTkgMTA1LjU1QzM3LjU4OTkgMTAzLjMgNDAuMDM5OSAxMDIuMTYgNDIuNjU5OSAxMDIuMTFDNDUuMjc5OSAxMDIuMDcgNDcuODc5OSAxMDMuMzIgNTAuNDU5OSAxMDUuODhMODEuNDQ5OSAxMzYuNThDODQuOTc5OSAxNDAuMDcgODguMzY5OSAxNDIuNTQgOTEuNjM5OSAxNDMuOTlDOTQuOTA5OSAxNDUuNDQgOTguMzQ5OSAxNDUuNjYgMTAxLjk2IDE0NC42N0MxMDUuNTcgMTQzLjY4IDEwOS40NCAxNDEuMTMgMTEzLjU5IDEzNy4wMkMxMTkuMzEgMTMxLjM1IDEyMi4wNCAxMjYuMDMgMTIxLjc2IDEyMS4wNkMxMjEuNDggMTE2LjA5IDExOC42NCAxMTAuOTMgMTEzLjI1IDEwNS41OUw5Ni41OTk5IDg5LjI0MDFDOTMuOTg5OSA4Ni42NjAxIDkyLjcwOTkgODQuMDgwMSA5Mi43NDk5IDgxLjUyMDFDOTIuNzg5OSA3OC45NTAxIDkzLjkwOTkgNzYuNTgwMSA5Ni4xMTk5IDc0LjM5MDFDOTguMzE5OSA3Mi4yMTAxIDEwMC43NSA3MS4wNzAxIDEwMy4zOSA3MC45ODAxQzEwNi4wMyA3MC44OTAxIDEwOC42NiA3Mi4xNDAxIDExMS4yNiA3NC43MjAxTDEyNi45NiA5MC4xMzAxQzEzMS44OSA5NS4wMTAxIDEzNS40NSA5OS42MzAxIDEzNy42NCAxMDMuOTlDMTM5LjgzIDEwOC4zNSAxNDAuNjUgMTEzLjI4IDE0MC4wOCAxMTguNzhDMTM5LjU3IDEyMy40OSAxMzguMDYgMTI4LjA1IDEzNS41NCAxMzIuNDdDMTMzLjAzIDEzNi44OSAxMjkuNDMgMTQxLjQxIDEyNC43NiAxNDYuMDRDMTE5LjIgMTUxLjU1IDExMy44OSAxNTUuNzcgMTA4LjgzIDE1OC43MUMxMDMuNzcgMTYxLjY1IDk4Ljg3OTkgMTYzLjI5IDk0LjE0OTkgMTYzLjYzQzg5LjQxOTkgMTYzLjk3IDg0Ljc1OTkgMTYzLjAzIDgwLjE0OTkgMTYwLjgxQzc1LjUzOTkgMTU4LjU5IDcwLjg1OTkgMTU1LjEzIDY2LjA5OTkgMTUwLjQxTDY2LjEwOTkgMTUwLjQyWiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzEwMDUwXzQxNzEpIi8+CjxwYXRoIGQ9Ik04NS4wMDk5IDcyLjk1OTJDOTEuMTU2OCA3Mi45NTkyIDk2LjEzOTkgNjcuOTc2MSA5Ni4xMzk5IDYxLjgyOTJDOTYuMTM5OSA1NS42ODIzIDkxLjE1NjggNTAuNjk5MiA4NS4wMDk5IDUwLjY5OTJDNzguODYzIDUwLjY5OTIgNzMuODc5OSA1NS42ODIzIDczLjg3OTkgNjEuODI5MkM3My44Nzk5IDY3Ljk3NjEgNzguODYzIDcyLjk1OTIgODUuMDA5OSA3Mi45NTkyWiIgZmlsbD0idXJsKCNwYWludDJfcmFkaWFsXzEwMDUwXzQxNzEpIi8+CjwvZz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xMDA1MF80MTcxIiB4MT0iMTM4Ljk4NSIgeTE9IjQ2Ljc3OTUiIHgyPSI0NS4wNTI5IiB5Mj0iODguNTIzMyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMjAxQzFCIi8+CjxzdG9wIG9mZnNldD0iMC4zNiIgc3RvcC1jb2xvcj0iIzc3MzkwRCIvPgo8c3RvcCBvZmZzZXQ9IjAuNjciIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRjRCODUyIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQxX2xpbmVhcl8xMDA1MF80MTcxIiB4MT0iNDMuMzgxMiIgeTE9IjEzNC4xNjciIHgyPSIxNTIuMjMxIiB5Mj0iMTAxLjc3MSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMUYxRDFDIi8+CjxzdG9wIG9mZnNldD0iMC4zNyIgc3RvcC1jb2xvcj0iIzc3MzkwRCIvPgo8c3RvcCBvZmZzZXQ9IjAuNjciIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRjRGQjUyIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQyX3JhZGlhbF8xMDA1MF80MTcxIiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDg1LjAwOTkgNjEuODM5Mikgc2NhbGUoMTEuMTMpIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y0Qjg1MiIvPgo8c3RvcCBvZmZzZXQ9IjAuMzMiIHN0b3AtY29sb3I9IiNFQTgxMDEiLz4KPHN0b3Agb2Zmc2V0PSIwLjY0IiBzdG9wLWNvbG9yPSIjNzczOTBEIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzIxMUMxRCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEwMDUwXzQxNzEiPgo8cmVjdCB3aWR0aD0iMTE1Ljc3IiBoZWlnaHQ9IjE0Ny43IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzIgMTYpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg=="
  }
};
var defaultAdapters = {
  [DefaultAdaptersInfo.fordefi.id]: FordefiAdapter,
  [DefaultAdaptersInfo.xverse.id]: XverseAdapter,
  [DefaultAdaptersInfo.unisat.id]: UnisatAdapter
};

// src/capabilities/index.ts
import { createUnsecuredToken as createUnsecuredToken2 } from "jsontokens";
var extractOrValidateCapabilities = (provider, reportedCapabilities) => {
  const validateCapability = (capability) => {
    if (!provider[capability]) {
      return false;
    }
    if (reportedCapabilities && !reportedCapabilities.has(capability)) {
      return false;
    }
    return true;
  };
  const capabilityMap = {
    request: validateCapability("request"),
    connect: validateCapability("connect"),
    signMessage: validateCapability("signMessage"),
    signTransaction: validateCapability("signTransaction"),
    sendBtcTransaction: validateCapability("sendBtcTransaction"),
    createInscription: validateCapability("createInscription"),
    createRepeatInscriptions: validateCapability("createRepeatInscriptions"),
    signMultipleTransactions: validateCapability("signMultipleTransactions"),
    addListener: validateCapability("addListener")
  };
  return Object.entries(capabilityMap).reduce((acc, [capability, value]) => {
    if (value) return [...acc, capability];
    return acc;
  }, []);
};
var getCapabilities = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const request2 = createUnsecuredToken2(options.payload);
  if (provider.getCapabilities) {
    try {
      const response = await provider.getCapabilities(request2);
      options.onFinish?.(extractOrValidateCapabilities(provider, new Set(response)));
    } catch (error) {
      console.error("[Connect] Error during capabilities request", error);
    }
  }
  try {
    const inferredCapabilities = extractOrValidateCapabilities(provider);
    options.onFinish?.(inferredCapabilities);
  } catch (error) {
    console.error("[Connect] Error during capabilities request", error);
    options.onCancel?.();
  }
};

// src/inscriptions/createInscription.ts
import { createUnsecuredToken as createUnsecuredToken3 } from "jsontokens";

// src/inscriptions/utils.ts
var MAX_CONTENT_LENGTH_MAINNET = 4e5;
var MAX_CONTENT_LENGTH_TESTNET = 6e4;
var validateInscriptionPayload = (payload) => {
  const { contentType, content, payloadType, network, appFeeAddress, appFee } = payload;
  if (!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(contentType)) {
    throw new Error("Invalid content type detected");
  }
  if (!content || content.length === 0) {
    throw new Error("Empty content not allowed");
  }
  if (!payloadType || payloadType !== "BASE_64" && payloadType !== "PLAIN_TEXT") {
    throw new Error("Empty invalid payloadType specified");
  }
  if (content.length > (network.type === "Mainnet" ? MAX_CONTENT_LENGTH_MAINNET : MAX_CONTENT_LENGTH_TESTNET)) {
    throw new Error("Content too large");
  }
  if ((appFeeAddress?.length ?? 0) > 0 && (appFee ?? 0) <= 0) {
    throw new Error("Invalid combination of app fee address and fee provided");
  }
};

// src/inscriptions/createInscription.ts
var createInscription = async (options) => {
  const { getProvider } = options;
  const provider = await getProviderOrThrow(getProvider);
  validateInscriptionPayload(options.payload);
  try {
    const request2 = createUnsecuredToken3(options.payload);
    const response = await provider.createInscription(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during create inscription", error);
    options.onCancel?.();
  }
};

// src/inscriptions/createRepeatInscriptions.ts
import { createUnsecuredToken as createUnsecuredToken4 } from "jsontokens";
var createRepeatInscriptions = async (options) => {
  const { getProvider } = options;
  const provider = await getProviderOrThrow(getProvider);
  validateInscriptionPayload(options.payload);
  try {
    const request2 = createUnsecuredToken4(options.payload);
    const response = await provider.createRepeatInscriptions(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during create repeat inscriptions", error);
    options.onCancel?.();
  }
};

// src/messages/index.ts
import { createUnsecuredToken as createUnsecuredToken5 } from "jsontokens";
var signMessage = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { address, message } = options.payload;
  if (!address) {
    throw new Error("An address is required to sign a message");
  }
  if (!message) {
    throw new Error("A message to be signed is required");
  }
  try {
    const request2 = createUnsecuredToken5(options.payload);
    const response = await provider.signMessage(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during sign message request", error);
    options.onCancel?.();
  }
};

// src/transactions/sendBtcTransaction.ts
import { createUnsecuredToken as createUnsecuredToken6 } from "jsontokens";
var serializer = (recipient) => {
  return recipient.map((value) => {
    const { address, amountSats } = value;
    return {
      address,
      amountSats: amountSats.toString()
    };
  });
};
var sendBtcTransaction = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { recipients, senderAddress, network, message } = options.payload;
  if (!recipients || recipients.length === 0) {
    throw new Error("At least one recipient is required");
  }
  if (recipients.some(
    (item) => typeof item.address !== "string" || typeof item.amountSats !== "bigint"
  )) {
    throw new Error("Incorrect recipient format");
  }
  if (!senderAddress) {
    throw new Error("The sender address is required");
  }
  try {
    const serializedRecipients = serializer(recipients);
    const serializedPayload = {
      network,
      senderAddress,
      message,
      recipients: serializedRecipients
    };
    const request2 = createUnsecuredToken6(serializedPayload);
    const response = await provider.sendBtcTransaction(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during send BTC transaction request", error);
    options.onCancel?.();
  }
};

// src/transactions/signTransaction.ts
import { createUnsecuredToken as createUnsecuredToken7 } from "jsontokens";
var signTransaction = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { psbtBase64, inputsToSign } = options.payload;
  if (!psbtBase64) {
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  }
  if (!inputsToSign) {
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  }
  try {
    const request2 = createUnsecuredToken7(options.payload);
    const response = await provider.signTransaction(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during sign transaction request", error);
    options.onCancel?.();
  }
};

// src/transactions/signMultipleTransactions.ts
import { createUnsecuredToken as createUnsecuredToken8 } from "jsontokens";
var signMultipleTransactions = async (options) => {
  const provider = await getProviderOrThrow(options.getProvider);
  const { psbts } = options.payload;
  if (!psbts || !psbts.length) {
    throw new Error("psbts array is required");
  }
  if (psbts.length > 100) {
    throw new Error("psbts array must contain less than 100 psbts");
  }
  try {
    const request2 = createUnsecuredToken8(options.payload);
    const response = await provider.signMultipleTransactions(request2);
    options.onFinish?.(response);
  } catch (error) {
    console.error("[Connect] Error during sign Multiple transactions request", error);
    options.onCancel?.();
  }
};
export {
  AddressPurpose,
  AddressType,
  BaseAdapter,
  BitcoinNetworkType,
  DefaultAdaptersInfo,
  MessageSigningProtocols,
  PermissionRequestParams,
  RpcErrorCode,
  RpcIdSchema,
  SatsConnectAdapter,
  StacksNetworkType,
  StarknetNetworkType,
  accountActionsSchema,
  accountChangeEventName,
  accountChangeSchema,
  accountPermissionSchema,
  addListener,
  addNetworkMethodName,
  addNetworkParamsSchema,
  addNetworkRequestMessageSchema,
  addNetworkResultSchema,
  addressSchema,
  changeNetworkByIdMethodName,
  changeNetworkByIdParamsSchema,
  changeNetworkByIdRequestMessageSchema,
  changeNetworkByIdResultSchema,
  changeNetworkMethodName,
  changeNetworkParamsSchema,
  changeNetworkRequestMessageSchema,
  changeNetworkResultSchema,
  connectMethodName,
  connectParamsSchema,
  connectRequestMessageSchema,
  connectResultSchema,
  createInscription,
  createRepeatInscriptions,
  defaultAdapters,
  disconnectEventName,
  disconnectMethodName,
  disconnectParamsSchema,
  disconnectRequestMessageSchema,
  disconnectResultSchema,
  disconnectSchema,
  getAccountMethodName,
  getAccountParamsSchema,
  getAccountRequestMessageSchema,
  getAccountResultSchema,
  getAccountsMethodName,
  getAccountsParamsSchema,
  getAccountsRequestMessageSchema,
  getAccountsResultSchema,
  getAddress,
  getAddressesMethodName,
  getAddressesParamsSchema,
  getAddressesRequestMessageSchema,
  getAddressesResultSchema,
  getBalanceMethodName,
  getBalanceParamsSchema,
  getBalanceRequestMessageSchema,
  getBalanceResultSchema,
  getCapabilities,
  getCurrentPermissionsMethodName,
  getCurrentPermissionsParamsSchema,
  getCurrentPermissionsRequestMessageSchema,
  getCurrentPermissionsResultSchema,
  getDefaultProvider,
  getInfoMethodName,
  getInfoParamsSchema,
  getInfoRequestMessageSchema,
  getInfoResultSchema,
  getInscriptionsMethodName,
  getInscriptionsParamsSchema,
  getInscriptionsRequestMessageSchema,
  getInscriptionsResultSchema,
  getNetworkMethodName,
  getNetworkParamsSchema,
  getNetworkRequestMessageSchema,
  getNetworkResultSchema,
  getProviderById,
  getProviderOrThrow,
  getProviders,
  getSupportedWallets,
  getWalletTypeMethodName,
  getWalletTypeParamsSchema,
  getWalletTypeRequestMessageSchema,
  getWalletTypeResultSchema,
  isProviderInstalled,
  networkChangeEventName,
  networkChangeSchema,
  permission,
  removeDefaultProvider,
  renouncePermissionsMethodName,
  renouncePermissionsParamsSchema,
  renouncePermissionsRequestMessageSchema,
  renouncePermissionsResultSchema,
  request,
  requestPermissionsMethodName,
  requestPermissionsParamsSchema,
  requestPermissionsRequestMessageSchema,
  requestPermissionsResultSchema,
  rpcErrorResponseMessageSchema,
  rpcRequestMessageSchema,
  rpcResponseMessageSchema,
  rpcSuccessResponseMessageSchema,
  runesEtchMethodName,
  runesEtchParamsSchema,
  runesEtchRequestMessageSchema,
  runesEtchResultSchema,
  runesGetBalanceMethodName,
  runesGetBalanceParamsSchema,
  runesGetBalanceRequestMessageSchema,
  runesGetBalanceResultSchema,
  runesMintMethodName,
  runesMintParamsSchema,
  runesMintRequestMessageSchema,
  runesMintResultSchema,
  runesTransferMethodName,
  runesTransferParamsSchema,
  runesTransferRequestMessageSchema,
  runesTransferResultSchema,
  sendBtcTransaction,
  sendInscriptionsMethodName,
  sendInscriptionsParamsSchema,
  sendInscriptionsRequestMessageSchema,
  sendInscriptionsResultSchema,
  sendTransferMethodName,
  sendTransferParamsSchema,
  sendTransferRequestMessageSchema,
  sendTransferResultSchema,
  setDefaultProvider,
  signMessage,
  signMessageMethodName,
  signMessageParamsSchema,
  signMessageRequestMessageSchema,
  signMessageResultSchema,
  signMultipleTransactions,
  signPsbtMethodName,
  signPsbtParamsSchema,
  signPsbtRequestMessageSchema,
  signPsbtResultSchema,
  signTransaction,
  stxCallContractMethodName,
  stxCallContractParamsSchema,
  stxCallContractRequestMessageSchema,
  stxCallContractResultSchema,
  stxDeployContractMethodName,
  stxDeployContractParamsSchema,
  stxDeployContractRequestMessageSchema,
  stxDeployContractResultSchema,
  stxGetAccountsMethodName,
  stxGetAccountsParamsSchema,
  stxGetAccountsRequestMessageSchema,
  stxGetAccountsResultSchema,
  stxGetAddressesMethodName,
  stxGetAddressesParamsSchema,
  stxGetAddressesRequestMessageSchema,
  stxGetAddressesResultSchema,
  stxSignMessageMethodName,
  stxSignMessageParamsSchema,
  stxSignMessageRequestMessageSchema,
  stxSignMessageResultSchema,
  stxSignStructuredMessageMethodName,
  stxSignStructuredMessageParamsSchema,
  stxSignStructuredMessageRequestMessageSchema,
  stxSignStructuredMessageResultSchema,
  stxSignTransactionMethodName,
  stxSignTransactionParamsSchema,
  stxSignTransactionRequestMessageSchema,
  stxSignTransactionResultSchema,
  stxSignTransactionsMethodName,
  stxSignTransactionsParamsSchema,
  stxSignTransactionsRequestMessageSchema,
  stxSignTransactionsResultSchema,
  stxTransferStxMethodName,
  stxTransferStxParamsSchema,
  stxTransferStxRequestMessageSchema,
  stxTransferStxResultSchema,
  walletActionsSchema,
  walletEventSchema,
  walletPermissionSchema,
  walletTypeSchema,
  walletTypes
};
