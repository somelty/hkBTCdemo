import * as v from 'valibot';

declare enum AddressPurpose {
    Ordinals = "ordinals",
    Payment = "payment",
    Stacks = "stacks"
}
interface GetAddressPayload extends RequestPayload {
    purposes: AddressPurpose[];
    message: string;
}
declare enum AddressType {
    p2pkh = "p2pkh",
    p2sh = "p2sh",
    p2wpkh = "p2wpkh",
    p2wsh = "p2wsh",
    p2tr = "p2tr",
    stacks = "stacks"
}
declare const addressSchema: v.ObjectSchema<{
    readonly address: v.StringSchema<undefined>;
    readonly publicKey: v.StringSchema<undefined>;
    readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>;
    readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
    readonly walletType: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
}, undefined>;
type Address = v.InferOutput<typeof addressSchema>;
interface GetAddressResponse {
    addresses: Address[];
}
type GetAddressOptions = RequestOptions<GetAddressPayload, GetAddressResponse>;

/**
 * @deprecated Use `request()` instead
 */
declare const getAddress: (options: GetAddressOptions) => Promise<void>;

interface GetCapabilitiesPayload extends RequestPayload {
}
type GetCapabilitiesResponse = Capability[];
type GetCapabilitiesOptions = RequestOptions<GetCapabilitiesPayload, GetCapabilitiesResponse>;

declare const getCapabilities: (options: GetCapabilitiesOptions) => Promise<void>;

interface CreateInscriptionPayload extends RequestPayload {
    contentType: string;
    content: string;
    payloadType: 'PLAIN_TEXT' | 'BASE_64';
    appFee?: number;
    appFeeAddress?: string;
    suggestedMinerFeeRate?: number;
    token?: string;
}
interface CreateRepeatInscriptionsPayload extends CreateInscriptionPayload {
    repeat: number;
}
type CreateInscriptionResponse = {
    txId: string;
};
type CreateRepeatInscriptionsResponse = {
    txId: string;
};
type CreateInscriptionOptions = RequestOptions<CreateInscriptionPayload, CreateInscriptionResponse>;
type CreateRepeatInscriptionsOptions = RequestOptions<CreateRepeatInscriptionsPayload, CreateRepeatInscriptionsResponse>;

declare const createInscription: (options: CreateInscriptionOptions) => Promise<void>;

declare const createRepeatInscriptions: (options: CreateRepeatInscriptionsOptions) => Promise<void>;

interface SignMessagePayload extends RequestPayload {
    address: string;
    message: string;
    protocol?: MessageSigningProtocols;
}
type SignMessageResponse = string;
type SignMessageOptions = RequestOptions<SignMessagePayload, SignMessageResponse>;

declare const signMessage: (options: SignMessageOptions) => Promise<void>;

interface Recipient {
    address: string;
    amountSats: bigint;
}
type SerializedRecipient = Omit<Recipient, 'amountSats'> & {
    amountSats: string;
};
interface SendBtcTransactionPayload extends RequestPayload {
    recipients: Recipient[];
    senderAddress: string;
    message?: string;
}
type SerializedSendBtcTransactionPayload = Omit<SendBtcTransactionPayload, 'recipients'> & {
    recipients: SerializedRecipient[];
};
type SendBtcTransactionResponse = string;
type SendBtcTransactionOptions = RequestOptions<SendBtcTransactionPayload, SendBtcTransactionResponse>;
interface InputToSign {
    address: string;
    signingIndexes: number[];
    sigHash?: number;
}
type PsbtPayload = {
    psbtBase64: string;
    inputsToSign?: InputToSign[];
    broadcast?: boolean;
};
type SignMultiplePsbtPayload = {
    psbtBase64: string;
    inputsToSign?: InputToSign[];
};
interface SignTransactionPayload extends RequestPayload, PsbtPayload {
    message: string;
}
interface SignTransactionResponse {
    psbtBase64: string;
    txId?: string;
}
type SignTransactionOptions = RequestOptions<SignTransactionPayload, SignTransactionResponse>;
interface SignMultipleTransactionsPayload extends RequestPayload {
    message: string;
    psbts: SignMultiplePsbtPayload[];
}
type SignMultipleTransactionsResponse = SignTransactionResponse[];
type SignMultipleTransactionOptions = RequestOptions<SignMultipleTransactionsPayload, SignMultipleTransactionsResponse>;

declare const sendBtcTransaction: (options: SendBtcTransactionOptions) => Promise<void>;

declare const signTransaction: (options: SignTransactionOptions) => Promise<void>;

declare const signMultipleTransactions: (options: SignMultipleTransactionOptions) => Promise<void>;

declare const accountChangeEventName = "accountChange";
declare const accountChangeSchema: v.ObjectSchema<{
    readonly type: v.LiteralSchema<"accountChange", undefined>;
    readonly addresses: v.OptionalSchema<v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly publicKey: v.StringSchema<undefined>;
        readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>;
        readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
        readonly walletType: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
    }, undefined>, undefined>, undefined>;
}, undefined>;
type AccountChangeEvent = v.InferOutput<typeof accountChangeSchema>;
declare const networkChangeEventName = "networkChange";
declare const networkChangeSchema: v.ObjectSchema<{
    readonly type: v.LiteralSchema<"networkChange", undefined>;
    readonly bitcoin: v.ObjectSchema<{
        readonly name: v.EnumSchema<typeof BitcoinNetworkType, undefined>;
    }, undefined>;
    readonly stacks: v.ObjectSchema<{
        readonly name: v.StringSchema<undefined>;
    }, undefined>;
    readonly addresses: v.OptionalSchema<v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly publicKey: v.StringSchema<undefined>;
        readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>;
        readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
        readonly walletType: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
    }, undefined>, undefined>, undefined>;
}, undefined>;
type NetworkChangeEvent = v.InferOutput<typeof networkChangeSchema>;
declare const disconnectEventName = "disconnect";
declare const disconnectSchema: v.ObjectSchema<{
    readonly type: v.LiteralSchema<"disconnect", undefined>;
}, undefined>;
type DisconnectEvent = v.InferOutput<typeof disconnectSchema>;
declare const walletEventSchema: v.VariantSchema<"type", [v.ObjectSchema<{
    readonly type: v.LiteralSchema<"accountChange", undefined>;
    readonly addresses: v.OptionalSchema<v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly publicKey: v.StringSchema<undefined>;
        readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>;
        readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
        readonly walletType: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
    }, undefined>, undefined>, undefined>;
}, undefined>, v.ObjectSchema<{
    readonly type: v.LiteralSchema<"networkChange", undefined>;
    readonly bitcoin: v.ObjectSchema<{
        readonly name: v.EnumSchema<typeof BitcoinNetworkType, undefined>;
    }, undefined>;
    readonly stacks: v.ObjectSchema<{
        readonly name: v.StringSchema<undefined>;
    }, undefined>;
    readonly addresses: v.OptionalSchema<v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly publicKey: v.StringSchema<undefined>;
        readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>;
        readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
        readonly walletType: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
    }, undefined>, undefined>, undefined>;
}, undefined>, v.ObjectSchema<{
    readonly type: v.LiteralSchema<"disconnect", undefined>;
}, undefined>], undefined>;
type WalletEvent = v.InferOutput<typeof walletEventSchema>;
type AddListener = <const WalletEventName extends WalletEvent['type']>(eventName: WalletEventName, cb: (event: Extract<WalletEvent, {
    type: WalletEventName;
}>) => void) => () => void;
interface BaseBitcoinProvider {
    request: <Method extends keyof Requests>(method: Method, options: Params<Method>, providerId?: string) => Promise<RpcResponse<Method>>;
    connect: (request: string) => Promise<GetAddressResponse>;
    signMessage: (request: string) => Promise<SignMessageResponse>;
    signTransaction: (request: string) => Promise<SignTransactionResponse>;
    sendBtcTransaction: (request: string) => Promise<SendBtcTransactionResponse>;
    createInscription: (request: string) => Promise<CreateInscriptionResponse>;
    createRepeatInscriptions: (request: string) => Promise<CreateRepeatInscriptionsResponse>;
    signMultipleTransactions: (request: string) => Promise<SignMultipleTransactionsResponse>;
    addListener: AddListener;
}
type Capability = keyof BaseBitcoinProvider;
interface BitcoinProvider extends BaseBitcoinProvider {
    getCapabilities?: (request: string) => Promise<GetCapabilitiesResponse>;
}
interface Provider {
    id: string;
    name: string;
    icon: string;
    webUrl?: string;
    chromeWebStoreUrl?: string;
    mozillaAddOnsUrl?: string;
    googlePlayStoreUrl?: string;
    iOSAppStoreUrl?: string;
    methods?: (StxRequestMethod | BtcRequestMethod | RunesRequestMethod | OrdinalsRequestMethod)[];
}
interface SupportedWallet extends Provider {
    isInstalled: boolean;
}
declare global {
    interface XverseProviders {
        BitcoinProvider?: BitcoinProvider;
    }
    interface Window {
        BitcoinProvider?: BitcoinProvider;
        XverseProviders?: XverseProviders;
        btc_providers?: Provider[];
    }
}

declare function getProviderOrThrow(getProvider?: () => Promise<BitcoinProvider | undefined>): Promise<BitcoinProvider>;
declare function getProviders(): Provider[];
declare function getProviderById(providerId: string): any;
declare function isProviderInstalled(providerId: string): boolean;
declare function setDefaultProvider(providerId: string): void;
declare function getDefaultProvider(): string | null;
declare function removeDefaultProvider(): void;
declare function getSupportedWallets(): SupportedWallet[];

declare enum BitcoinNetworkType {
    Mainnet = "Mainnet",
    Testnet = "Testnet",
    Testnet4 = "Testnet4",
    Signet = "Signet",
    Regtest = "Regtest"
}
declare enum StacksNetworkType {
    Mainnet = "mainnet",
    Testnet = "testnet"
}
declare enum StarknetNetworkType {
    Mainnet = "mainnet",
    Sepolia = "sepolia"
}
interface BitcoinNetwork {
    type: BitcoinNetworkType;
    address?: string;
}
interface RequestPayload {
    network: BitcoinNetwork;
}
interface RequestOptions<Payload extends RequestPayload, Response> {
    onFinish: (response: Response) => void;
    onCancel: () => void;
    payload: Payload;
    getProvider?: () => Promise<BitcoinProvider | undefined>;
}
declare const RpcIdSchema: v.OptionalSchema<v.UnionSchema<[v.StringSchema<undefined>, v.NumberSchema<undefined>, v.NullSchema<undefined>], undefined>, undefined>;
type RpcId = v.InferOutput<typeof RpcIdSchema>;
declare const rpcRequestMessageSchema: v.ObjectSchema<{
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
    readonly method: v.StringSchema<undefined>;
    readonly params: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnknownSchema, undefined>, v.LooseObjectSchema<{}, undefined>, v.NullSchema<undefined>], undefined>, undefined>;
    readonly id: v.UnionSchema<[v.StringSchema<undefined>, v.NumberSchema<undefined>, v.NullSchema<undefined>], undefined>;
}, undefined>;
type RpcRequestMessage = v.InferOutput<typeof rpcRequestMessageSchema>;
interface RpcBase {
    jsonrpc: '2.0';
    id: RpcId;
}
interface RpcRequest<T extends string, U> extends RpcBase {
    method: T;
    params: U;
}
interface MethodParamsAndResult<TParams, TResult> {
    params: TParams;
    result: TResult;
}
/**
 * @enum {number} RpcErrorCode
 * @description JSON-RPC error codes
 * @see https://www.jsonrpc.org/specification#error_object
 */
declare enum RpcErrorCode {
    /**
     * Parse error Invalid JSON
     **/
    PARSE_ERROR = -32700,
    /**
     * The JSON sent is not a valid Request object.
     **/
    INVALID_REQUEST = -32600,
    /**
     * The method does not exist/is not available.
     **/
    METHOD_NOT_FOUND = -32601,
    /**
     * Invalid method parameter(s).
     */
    INVALID_PARAMS = -32602,
    /**
     * Internal JSON-RPC error.
     * This is a generic error, used when the server encounters an error in performing the request.
     **/
    INTERNAL_ERROR = -32603,
    /**
     * user rejected/canceled the request
     */
    USER_REJECTION = -32000,
    /**
     * method is not supported for the address provided
     */
    METHOD_NOT_SUPPORTED = -32001,
    /**
     * The client does not have permission to access the requested resource.
     */
    ACCESS_DENIED = -32002
}
declare const rpcSuccessResponseMessageSchema: v.ObjectSchema<{
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
    readonly result: v.NonOptionalSchema<v.UnknownSchema, undefined>;
    readonly id: v.OptionalSchema<v.UnionSchema<[v.StringSchema<undefined>, v.NumberSchema<undefined>, v.NullSchema<undefined>], undefined>, undefined>;
}, undefined>;
type RpcSuccessResponseMessage = v.InferOutput<typeof rpcSuccessResponseMessageSchema>;
declare const rpcErrorResponseMessageSchema: v.ObjectSchema<{
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
    readonly error: v.NonOptionalSchema<v.UnknownSchema, undefined>;
    readonly id: v.OptionalSchema<v.UnionSchema<[v.StringSchema<undefined>, v.NumberSchema<undefined>, v.NullSchema<undefined>], undefined>, undefined>;
}, undefined>;
type RpcErrorResponseMessage = v.InferOutput<typeof rpcErrorResponseMessageSchema>;
declare const rpcResponseMessageSchema: v.UnionSchema<[v.ObjectSchema<{
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
    readonly result: v.NonOptionalSchema<v.UnknownSchema, undefined>;
    readonly id: v.OptionalSchema<v.UnionSchema<[v.StringSchema<undefined>, v.NumberSchema<undefined>, v.NullSchema<undefined>], undefined>, undefined>;
}, undefined>, v.ObjectSchema<{
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
    readonly error: v.NonOptionalSchema<v.UnknownSchema, undefined>;
    readonly id: v.OptionalSchema<v.UnionSchema<[v.StringSchema<undefined>, v.NumberSchema<undefined>, v.NullSchema<undefined>], undefined>, undefined>;
}, undefined>], undefined>;
type RpcResponseMessage = v.InferOutput<typeof rpcResponseMessageSchema>;
interface RpcError {
    code: number | RpcErrorCode;
    message: string;
    data?: any;
}
interface RpcErrorResponse<TError extends RpcError = RpcError> extends RpcBase {
    error: TError;
}
interface RpcSuccessResponse<Method extends keyof Requests> extends RpcBase {
    result: Return<Method>;
}
type RpcResponse<Method extends keyof Requests> = RpcSuccessResponse<Method> | RpcErrorResponse;
type RpcResult<Method extends keyof Requests> = {
    result: RpcSuccessResponse<Method>['result'];
    status: 'success';
} | {
    error: RpcErrorResponse['error'];
    status: 'error';
};

declare const getInfoMethodName = "getInfo";
declare const getInfoParamsSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type GetInfoParams = v.InferOutput<typeof getInfoParamsSchema>;
declare const getInfoResultSchema: v.ObjectSchema<{
    /**
     * Version of the wallet.
     */
    readonly version: v.StringSchema<undefined>;
    /**
     * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
     */
    readonly methods: v.OptionalSchema<v.ArraySchema<v.StringSchema<undefined>, undefined>, undefined>;
    /**
     * List of WBIP standards supported by the wallet. Not currently used.
     */
    readonly supports: v.ArraySchema<v.StringSchema<undefined>, undefined>;
}, undefined>;
type GetInfoResult = v.InferOutput<typeof getInfoResultSchema>;
declare const getInfoRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"getInfo", undefined>;
    readonly params: v.NullishSchema<v.NullSchema<undefined>, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type GetInfoRequestMessage = v.InferOutput<typeof getInfoRequestMessageSchema>;
type GetInfo = MethodParamsAndResult<v.InferOutput<typeof getInfoParamsSchema>, v.InferOutput<typeof getInfoResultSchema>>;
declare const getAddressesMethodName = "getAddresses";
declare const getAddressesParamsSchema: v.ObjectSchema<{
    /**
     * The purposes for which to generate addresses. See
     * {@linkcode AddressPurpose} for available purposes.
     */
    readonly purposes: v.ArraySchema<v.EnumSchema<typeof AddressPurpose, undefined>, undefined>;
    /**
     * A message to be displayed to the user in the request prompt.
     */
    readonly message: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
}, undefined>;
type GetAddressesParams = v.InferOutput<typeof getAddressesParamsSchema>;
declare const getAddressesResultSchema: v.ObjectSchema<{
    /**
     * The addresses generated for the given purposes.
     */
    readonly addresses: v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly publicKey: v.StringSchema<undefined>;
        readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>; /**
         * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
         */
        readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
        readonly walletType: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
    }, undefined>, undefined>;
    readonly network: v.ObjectSchema<{
        readonly bitcoin: v.ObjectSchema<{
            readonly name: v.EnumSchema<typeof BitcoinNetworkType, undefined>; /**
             * The purposes for which to generate addresses. See
             * {@linkcode AddressPurpose} for available purposes.
             */
        }, undefined>;
        readonly stacks: v.ObjectSchema<{
            readonly name: v.StringSchema<undefined>;
        }, undefined>;
    }, undefined>;
}, undefined>;
type GetAddressesResult = v.InferOutput<typeof getAddressesResultSchema>;
declare const getAddressesRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"getAddresses", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * The purposes for which to generate addresses. See
         * {@linkcode AddressPurpose} for available purposes.
         */
        readonly purposes: v.ArraySchema<v.EnumSchema<typeof AddressPurpose, undefined>, undefined>;
        /**
         * A message to be displayed to the user in the request prompt.
         */
        readonly message: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type GetAddressesRequestMessage = v.InferOutput<typeof getAddressesRequestMessageSchema>;
type GetAddresses = MethodParamsAndResult<v.InferOutput<typeof getAddressesParamsSchema>, v.InferOutput<typeof getAddressesResultSchema>>;
declare const signMessageMethodName = "signMessage";
declare enum MessageSigningProtocols {
    ECDSA = "ECDSA",
    BIP322 = "BIP322"
}
declare const signMessageParamsSchema: v.ObjectSchema<{
    /**
     * The address used for signing.
     **/
    readonly address: v.StringSchema<undefined>;
    /**
     * The message to sign.
     **/
    readonly message: v.StringSchema<undefined>;
    /**
     * The protocol to use for signing the message.
     */
    readonly protocol: v.OptionalSchema<v.EnumSchema<typeof MessageSigningProtocols, undefined>, undefined>;
}, undefined>;
type SignMessageParams = v.InferOutput<typeof signMessageParamsSchema>;
declare const signMessageResultSchema: v.ObjectSchema<{
    /**
     * The signature of the message.
     */
    readonly signature: v.StringSchema<undefined>;
    /**
     * hash of the message.
     */
    readonly messageHash: v.StringSchema<undefined>;
    /**
     * The address used for signing.
     */
    readonly address: v.StringSchema<undefined>;
    /**
     * The protocol to use for signing the message.
     */
    readonly protocol: v.EnumSchema<typeof MessageSigningProtocols, undefined>;
}, undefined>;
type SignMessageResult = v.InferOutput<typeof signMessageResultSchema>;
declare const signMessageRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"signMessage", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * The address used for signing.
         **/
        readonly address: v.StringSchema<undefined>;
        /**
         * The message to sign.
         **/
        readonly message: v.StringSchema<undefined>;
        /**
         * The protocol to use for signing the message.
         */
        readonly protocol: v.OptionalSchema<v.EnumSchema<typeof MessageSigningProtocols, undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type SignMessageRequestMessage = v.InferOutput<typeof signMessageRequestMessageSchema>;
type SignMessage = MethodParamsAndResult<v.InferOutput<typeof signMessageParamsSchema>, v.InferOutput<typeof signMessageResultSchema>>;
declare const sendTransferMethodName = "sendTransfer";
declare const sendTransferParamsSchema: v.ObjectSchema<{
    /**
     * Array of recipients to send to.
     * The amount to send to each recipient is in satoshis.
     */
    readonly recipients: v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly amount: v.NumberSchema<undefined>;
    }, undefined>, undefined>;
}, undefined>;
type SendTransferParams = v.InferOutput<typeof sendTransferParamsSchema>;
declare const sendTransferResultSchema: v.ObjectSchema<{
    /**
     * The transaction id as a hex-encoded string.
     */
    readonly txid: v.StringSchema<undefined>;
}, undefined>;
type SendTransferResult = v.InferOutput<typeof sendTransferResultSchema>;
declare const sendTransferRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"sendTransfer", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * Array of recipients to send to.
         * The amount to send to each recipient is in satoshis.
         */
        readonly recipients: v.ArraySchema<v.ObjectSchema<{
            readonly address: v.StringSchema<undefined>;
            readonly amount: v.NumberSchema<undefined>;
        }, undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type SendTransferRequestMessage = v.InferOutput<typeof sendTransferRequestMessageSchema>;
type SendTransfer = MethodParamsAndResult<SendTransferParams, SendTransferResult>;
declare const signPsbtMethodName = "signPsbt";
declare const signPsbtParamsSchema: v.ObjectSchema<{
    /**
     * The base64 encoded PSBT to sign.
     */
    readonly psbt: v.StringSchema<undefined>;
    /**
     * The inputs to sign.
     * The key is the address and the value is an array of indexes of the inputs to sign.
     */
    readonly signInputs: v.OptionalSchema<v.RecordSchema<v.StringSchema<undefined>, v.ArraySchema<v.NumberSchema<undefined>, undefined>, undefined>, undefined>;
    /**
     * Whether to broadcast the transaction after signing.
     **/
    readonly broadcast: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
}, undefined>;
type SignPsbtParams = v.InferOutput<typeof signPsbtParamsSchema>;
declare const signPsbtResultSchema: v.ObjectSchema<{
    /**
     * The base64 encoded PSBT after signing.
     */
    readonly psbt: v.StringSchema<undefined>;
    /**
     * The transaction id as a hex-encoded string.
     * This is only returned if the transaction was broadcast.
     **/
    readonly txid: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
}, undefined>;
type SignPsbtResult = v.InferOutput<typeof signPsbtResultSchema>;
declare const signPsbtRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"signPsbt", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * The base64 encoded PSBT to sign.
         */
        readonly psbt: v.StringSchema<undefined>;
        /**
         * The inputs to sign.
         * The key is the address and the value is an array of indexes of the inputs to sign.
         */
        readonly signInputs: v.OptionalSchema<v.RecordSchema<v.StringSchema<undefined>, v.ArraySchema<v.NumberSchema<undefined>, undefined>, undefined>, undefined>;
        /**
         * Whether to broadcast the transaction after signing.
         **/
        readonly broadcast: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type SignPsbtRequestMessage = v.InferOutput<typeof signPsbtRequestMessageSchema>;
type SignPsbt = MethodParamsAndResult<SignPsbtParams, SignPsbtResult>;
declare const getAccountsMethodName = "getAccounts";
declare const getAccountsParamsSchema: v.ObjectSchema<{
    /**
     * The purposes for which to generate addresses. See
     * {@linkcode AddressPurpose} for available purposes.
     */
    readonly purposes: v.ArraySchema<v.EnumSchema<typeof AddressPurpose, undefined>, undefined>;
    /**
     * A message to be displayed to the user in the request prompt.
     */
    readonly message: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
}, undefined>;
type GetAccountsParams = v.InferOutput<typeof getAccountsParamsSchema>;
declare const getAccountsResultSchema: v.ArraySchema<v.ObjectSchema<{
    readonly walletType: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
    readonly address: v.StringSchema<undefined>;
    readonly publicKey: v.StringSchema<undefined>;
    readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>; /**
     * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
     */
    readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
}, undefined>, undefined>;
type GetAccountsResult = v.InferOutput<typeof getAccountsResultSchema>;
declare const getAccountsRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"getAccounts", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * The purposes for which to generate addresses. See
         * {@linkcode AddressPurpose} for available purposes.
         */
        readonly purposes: v.ArraySchema<v.EnumSchema<typeof AddressPurpose, undefined>, undefined>;
        /**
         * A message to be displayed to the user in the request prompt.
         */
        readonly message: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type GetAccountsRequestMessage = v.InferOutput<typeof getAccountsRequestMessageSchema>;
type GetAccounts = MethodParamsAndResult<v.InferOutput<typeof getAccountsParamsSchema>, v.InferOutput<typeof getAccountsResultSchema>>;
declare const getBalanceMethodName = "getBalance";
declare const getBalanceParamsSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type GetBalanceParams = v.InferOutput<typeof getBalanceParamsSchema>;
declare const getBalanceResultSchema: v.ObjectSchema<{
    /**
     * The confirmed balance of the wallet in sats. Using a string due to chrome
     * messages not supporting bigint
     * (https://issues.chromium.org/issues/40116184).
     */
    readonly confirmed: v.StringSchema<undefined>;
    /**
     * The unconfirmed balance of the wallet in sats. Using a string due to chrome
     * messages not supporting bigint
     * (https://issues.chromium.org/issues/40116184).
     */
    readonly unconfirmed: v.StringSchema<undefined>;
    /**
     * The total balance (both confirmed and unconfrimed UTXOs) of the wallet in
     * sats. Using a string due to chrome messages not supporting bigint
     * (https://issues.chromium.org/issues/40116184).
     */
    readonly total: v.StringSchema<undefined>;
}, undefined>;
type GetBalanceResult = v.InferOutput<typeof getBalanceResultSchema>;
declare const getBalanceRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"getBalance", undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
    readonly params: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnknownSchema, undefined>, v.LooseObjectSchema<{}, undefined>, v.NullSchema<undefined>], undefined>, undefined>;
}, undefined>;
type GetBalanceRequestMessage = v.InferOutput<typeof getBalanceRequestMessageSchema>;
type GetBalance = MethodParamsAndResult<GetBalanceParams, GetBalanceResult>;

declare const getInscriptionsMethodName = "ord_getInscriptions";
declare const getInscriptionsParamsSchema: v.ObjectSchema<{
    readonly offset: v.NumberSchema<undefined>;
    readonly limit: v.NumberSchema<undefined>;
}, undefined>;
type GetInscriptionsParams = v.InferOutput<typeof getInscriptionsParamsSchema>;
declare const getInscriptionsResultSchema: v.ObjectSchema<{
    readonly total: v.NumberSchema<undefined>;
    readonly limit: v.NumberSchema<undefined>;
    readonly offset: v.NumberSchema<undefined>;
    readonly inscriptions: v.ArraySchema<v.ObjectSchema<{
        readonly inscriptionId: v.StringSchema<undefined>;
        readonly inscriptionNumber: v.StringSchema<undefined>;
        readonly address: v.StringSchema<undefined>;
        readonly collectionName: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly postage: v.StringSchema<undefined>;
        readonly contentLength: v.StringSchema<undefined>;
        readonly contentType: v.StringSchema<undefined>;
        readonly timestamp: v.NumberSchema<undefined>;
        readonly offset: v.NumberSchema<undefined>;
        readonly genesisTransaction: v.StringSchema<undefined>;
        readonly output: v.StringSchema<undefined>;
    }, undefined>, undefined>;
}, undefined>;
type GetInscriptionsResult = v.InferOutput<typeof getInscriptionsResultSchema>;
declare const getInscriptionsRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"ord_getInscriptions", undefined>;
    readonly params: v.ObjectSchema<{
        readonly offset: v.NumberSchema<undefined>;
        readonly limit: v.NumberSchema<undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type GetInscriptionsRequestMessage = v.InferOutput<typeof getInscriptionsRequestMessageSchema>;
type GetInscriptions = MethodParamsAndResult<GetInscriptionsParams, GetInscriptionsResult>;
declare const sendInscriptionsMethodName = "ord_sendInscriptions";
declare const sendInscriptionsParamsSchema: v.ObjectSchema<{
    readonly transfers: v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly inscriptionId: v.StringSchema<undefined>;
    }, undefined>, undefined>;
}, undefined>;
type SendInscriptionsParams = v.InferOutput<typeof sendInscriptionsParamsSchema>;
declare const sendInscriptionsResultSchema: v.ObjectSchema<{
    readonly txid: v.StringSchema<undefined>;
}, undefined>;
type SendInscriptionsResult = v.InferOutput<typeof sendInscriptionsResultSchema>;
declare const sendInscriptionsRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"ord_sendInscriptions", undefined>;
    readonly params: v.ObjectSchema<{
        readonly transfers: v.ArraySchema<v.ObjectSchema<{
            readonly address: v.StringSchema<undefined>;
            readonly inscriptionId: v.StringSchema<undefined>;
        }, undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type SendInscriptionsRequestMessage = v.InferOutput<typeof sendInscriptionsRequestMessageSchema>;
type SendInscriptions = MethodParamsAndResult<SendInscriptionsParams, SendInscriptionsResult>;

type CreateMintOrderRequest = {
    runeName: string;
    repeats: number;
    refundAddress: string;
    destinationAddress: string;
    feeRate: number;
    appServiceFee?: number;
    appServiceFeeAddress?: string;
};
type EstimateMintOrderRequest = Omit<CreateMintOrderRequest, 'refundAddress'>;
type EstimateOrderResponse = {
    totalSize: number;
    totalCost: number;
    costBreakdown: {
        postage: number;
        networkFee: number;
        serviceFee: number;
        appServiceFee: number;
    };
};
type CreateEtchOrderRequest = {
    runeName: string;
    divisibility?: number;
    symbol?: string;
    premine?: string;
    isMintable: boolean;
    terms?: {
        amount?: string;
        cap?: string;
        heightStart?: string;
        heightEnd?: string;
        offsetStart?: string;
        offsetEnd?: string;
    };
    inscriptionDetails?: {
        contentType: string;
        contentBase64: string;
    };
    delegateInscriptionId?: string;
    destinationAddress: string;
    refundAddress: string;
    feeRate: number;
    appServiceFee?: number;
    appServiceFeeAddress?: string;
};
type EstimateEtchOrderRequest = Omit<CreateEtchOrderRequest, 'refundAddress'>;
type GetOrderRequest = {
    id: string;
};
type GetOrderResponse = {
    id: string;
    orderType: 'rune_mint' | 'rune_etch';
    state: 'new' | 'pending' | 'executing' | 'complete' | 'failed' | 'refunded' | 'stale';
    fundingAddress: string;
    reason?: string;
    createdAt: string;
};
type RBFOrderRequest = {
    orderId: string;
    newFeeRate: number;
};
type RBFOrderResponse = {
    rbfCost: number;
    fundingAddress: string;
};

interface RunesEstimateEtchParams extends EstimateEtchOrderRequest {
    network?: BitcoinNetworkType;
}
type RunesEstimateEtchResult = EstimateOrderResponse;
type RunesEstimateEtch = MethodParamsAndResult<RunesEstimateEtchParams, RunesEstimateEtchResult>;

interface runesEstimateMintParams extends EstimateMintOrderRequest {
    network?: BitcoinNetworkType;
}
type runesEstimateMintResult = EstimateOrderResponse;
type RunesEstimateMint = MethodParamsAndResult<runesEstimateMintParams, runesEstimateMintResult>;

interface RunesEstimateRbfOrderParams extends RBFOrderRequest {
    network?: BitcoinNetworkType;
}
type RunesEstimateRbfOrder = MethodParamsAndResult<RunesEstimateRbfOrderParams, RBFOrderResponse>;

declare const runesEtchMethodName = "runes_etch";
declare const runesEtchParamsSchema: v.ObjectSchema<{
    readonly runeName: v.StringSchema<undefined>;
    readonly divisibility: v.OptionalSchema<v.NumberSchema<undefined>, undefined>;
    readonly symbol: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    readonly premine: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    readonly isMintable: v.BooleanSchema<undefined>;
    readonly delegateInscriptionId: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    readonly destinationAddress: v.StringSchema<undefined>;
    readonly refundAddress: v.StringSchema<undefined>;
    readonly feeRate: v.NumberSchema<undefined>;
    readonly appServiceFee: v.OptionalSchema<v.NumberSchema<undefined>, undefined>;
    readonly appServiceFeeAddress: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    readonly terms: v.OptionalSchema<v.ObjectSchema<{
        readonly amount: v.StringSchema<undefined>;
        readonly cap: v.StringSchema<undefined>;
        readonly heightStart: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly heightEnd: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly offsetStart: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly offsetEnd: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    }, undefined>, undefined>;
    readonly inscriptionDetails: v.OptionalSchema<v.ObjectSchema<{
        readonly contentType: v.StringSchema<undefined>;
        readonly contentBase64: v.StringSchema<undefined>;
    }, undefined>, undefined>;
    readonly network: v.OptionalSchema<v.EnumSchema<typeof BitcoinNetworkType, undefined>, undefined>;
}, undefined>;
type RunesEtchParams = v.InferOutput<typeof runesEtchParamsSchema>;
declare const runesEtchResultSchema: v.ObjectSchema<{
    readonly orderId: v.StringSchema<undefined>;
    readonly fundTransactionId: v.StringSchema<undefined>;
    readonly fundingAddress: v.StringSchema<undefined>;
}, undefined>;
type RunesEtchResult = v.InferOutput<typeof runesEtchResultSchema>;
declare const runesEtchRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"runes_etch", undefined>;
    readonly params: v.ObjectSchema<{
        readonly runeName: v.StringSchema<undefined>;
        readonly divisibility: v.OptionalSchema<v.NumberSchema<undefined>, undefined>;
        readonly symbol: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly premine: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly isMintable: v.BooleanSchema<undefined>;
        readonly delegateInscriptionId: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly destinationAddress: v.StringSchema<undefined>;
        readonly refundAddress: v.StringSchema<undefined>;
        readonly feeRate: v.NumberSchema<undefined>;
        readonly appServiceFee: v.OptionalSchema<v.NumberSchema<undefined>, undefined>;
        readonly appServiceFeeAddress: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly terms: v.OptionalSchema<v.ObjectSchema<{
            readonly amount: v.StringSchema<undefined>;
            readonly cap: v.StringSchema<undefined>;
            readonly heightStart: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
            readonly heightEnd: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
            readonly offsetStart: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
            readonly offsetEnd: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        }, undefined>, undefined>;
        readonly inscriptionDetails: v.OptionalSchema<v.ObjectSchema<{
            readonly contentType: v.StringSchema<undefined>;
            readonly contentBase64: v.StringSchema<undefined>;
        }, undefined>, undefined>;
        readonly network: v.OptionalSchema<v.EnumSchema<typeof BitcoinNetworkType, undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type RunesEtchRequestMessage = v.InferOutput<typeof runesEtchRequestMessageSchema>;
type RunesEtch = MethodParamsAndResult<v.InferOutput<typeof runesEtchParamsSchema>, v.InferOutput<typeof runesEtchResultSchema>>;

declare const runesGetBalanceMethodName = "runes_getBalance";
declare const runesGetBalanceParamsSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type RunesGetBalanceParams = v.InferOutput<typeof runesGetBalanceParamsSchema>;
declare const runesGetBalanceResultSchema: v.ObjectSchema<{
    readonly balances: v.ArraySchema<v.ObjectSchema<{
        readonly runeName: v.StringSchema<undefined>;
        readonly amount: v.StringSchema<undefined>;
        readonly divisibility: v.NumberSchema<undefined>;
        readonly symbol: v.StringSchema<undefined>;
        readonly inscriptionId: v.NullishSchema<v.StringSchema<undefined>, undefined>;
        readonly spendableBalance: v.StringSchema<undefined>;
    }, undefined>, undefined>;
}, undefined>;
type RunesGetBalanceResult = v.InferOutput<typeof runesGetBalanceResultSchema>;
declare const runesGetBalanceRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"runes_getBalance", undefined>;
    readonly params: v.NullishSchema<v.NullSchema<undefined>, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type runesGetBalanceRequestMessage = v.InferOutput<typeof runesGetBalanceRequestMessageSchema>;
type RunesGetBalance = MethodParamsAndResult<RunesGetBalanceParams, RunesGetBalanceResult>;

interface RunesGetOrderParams extends GetOrderRequest {
    network?: BitcoinNetworkType;
}
type RunesGetOrder = MethodParamsAndResult<RunesGetOrderParams, GetOrderResponse>;

declare const runesMintMethodName = "runes_mint";
declare const runesMintParamsSchema: v.ObjectSchema<{
    readonly appServiceFee: v.OptionalSchema<v.NumberSchema<undefined>, undefined>;
    readonly appServiceFeeAddress: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    readonly destinationAddress: v.StringSchema<undefined>;
    readonly feeRate: v.NumberSchema<undefined>;
    readonly refundAddress: v.StringSchema<undefined>;
    readonly repeats: v.NumberSchema<undefined>;
    readonly runeName: v.StringSchema<undefined>;
    readonly network: v.OptionalSchema<v.EnumSchema<typeof BitcoinNetworkType, undefined>, undefined>;
}, undefined>;
type RunesMintParams = v.InferOutput<typeof runesMintParamsSchema>;
declare const runesMintResultSchema: v.ObjectSchema<{
    readonly orderId: v.StringSchema<undefined>;
    readonly fundTransactionId: v.StringSchema<undefined>;
    readonly fundingAddress: v.StringSchema<undefined>;
}, undefined>;
type RunesMintResult = v.InferOutput<typeof runesMintResultSchema>;
declare const runesMintRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"runes_mint", undefined>;
    readonly params: v.ObjectSchema<{
        readonly appServiceFee: v.OptionalSchema<v.NumberSchema<undefined>, undefined>;
        readonly appServiceFeeAddress: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly destinationAddress: v.StringSchema<undefined>;
        readonly feeRate: v.NumberSchema<undefined>;
        readonly refundAddress: v.StringSchema<undefined>;
        readonly repeats: v.NumberSchema<undefined>;
        readonly runeName: v.StringSchema<undefined>;
        readonly network: v.OptionalSchema<v.EnumSchema<typeof BitcoinNetworkType, undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type RunesMintRequestMessage = v.InferOutput<typeof runesMintRequestMessageSchema>;
type RunesMint = MethodParamsAndResult<v.InferOutput<typeof runesMintParamsSchema>, v.InferOutput<typeof runesMintResultSchema>>;

interface RunesRbfOrderParams extends RBFOrderRequest {
    network?: BitcoinNetworkType;
}
interface RunesRbfOrderResult {
    orderId: string;
    fundRBFTransactionId: string;
    fundingAddress: string;
}
type RunesRbfOrder = MethodParamsAndResult<RunesRbfOrderParams, RunesRbfOrderResult>;

declare const runesTransferMethodName = "runes_transfer";
declare const runesTransferParamsSchema: v.ObjectSchema<{
    readonly recipients: v.ArraySchema<v.ObjectSchema<{
        readonly runeName: v.StringSchema<undefined>;
        readonly amount: v.StringSchema<undefined>;
        readonly address: v.StringSchema<undefined>;
    }, undefined>, undefined>;
}, undefined>;
type TransferRunesParams = v.InferOutput<typeof runesTransferParamsSchema>;
declare const runesTransferResultSchema: v.ObjectSchema<{
    readonly txid: v.StringSchema<undefined>;
}, undefined>;
type RunesTransferResult = v.InferOutput<typeof runesTransferResultSchema>;
declare const runesTransferRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"runes_transfer", undefined>;
    readonly params: v.ObjectSchema<{
        readonly recipients: v.ArraySchema<v.ObjectSchema<{
            readonly runeName: v.StringSchema<undefined>;
            readonly amount: v.StringSchema<undefined>;
            readonly address: v.StringSchema<undefined>;
        }, undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type RunesTransferRequestMessage = v.InferOutput<typeof runesTransferRequestMessageSchema>;
type RunesTransfer = MethodParamsAndResult<TransferRunesParams, RunesTransferResult>;

declare const stxCallContractMethodName = "stx_callContract";
declare const stxCallContractParamsSchema: v.ObjectSchema<{
    /**
     * The contract principal.
     *
     * E.g. `"SPKE...GD5C.my-contract"`
     */
    readonly contract: v.StringSchema<undefined>;
    /**
     * The name of the function to call.
     *
     * Note: spec changes ongoing,
     * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
     */
    readonly functionName: v.StringSchema<undefined>;
    /**
     * @deprecated in favor of `functionArgs` for @stacks/connect compatibility
     */
    readonly arguments: v.OptionalSchema<v.ArraySchema<v.StringSchema<undefined>, undefined>, undefined>;
    /**
     * The function's arguments. The arguments are expected to be hex-encoded
     * strings of Clarity values.
     *
     * To convert Clarity values to their hex representation, the `cvToHex`
     * helper from the `@stacks/transactions` package may be helpful.
     *
     * ```js
     * import { cvToHex } from '@stacks/transactions';
     *
     * const functionArgs = [someClarityValue1, someClarityValue2];
     * const hexArgs = functionArgs.map(cvToHex);
     * ```
     */
    readonly functionArgs: v.OptionalSchema<v.ArraySchema<v.StringSchema<undefined>, undefined>, undefined>;
    /**
     * The post conditions to apply to the contract call.
     */
    readonly postConditions: v.OptionalSchema<v.ArraySchema<v.StringSchema<undefined>, undefined>, undefined>;
    /**
     * The mode to apply to the post conditions.
     */
    readonly postConditionMode: v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"allow", undefined>, v.LiteralSchema<"deny", undefined>], undefined>, undefined>;
}, undefined>;
type StxCallContractParams = v.InferOutput<typeof stxCallContractParamsSchema>;
declare const stxCallContractResultSchema: v.ObjectSchema<{
    /**
     * The ID of the transaction.
     */
    readonly txid: v.StringSchema<undefined>;
    /**
     * A Stacks transaction as a hex-encoded string.
     */
    readonly transaction: v.StringSchema<undefined>;
}, undefined>;
type StxCallContractResult = v.InferOutput<typeof stxCallContractResultSchema>;
declare const stxCallContractRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"stx_callContract", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * The contract principal.
         *
         * E.g. `"SPKE...GD5C.my-contract"`
         */
        readonly contract: v.StringSchema<undefined>;
        /**
         * The name of the function to call.
         *
         * Note: spec changes ongoing,
         * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
         */
        readonly functionName: v.StringSchema<undefined>;
        /**
         * @deprecated in favor of `functionArgs` for @stacks/connect compatibility
         */
        readonly arguments: v.OptionalSchema<v.ArraySchema<v.StringSchema<undefined>, undefined>, undefined>;
        /**
         * The function's arguments. The arguments are expected to be hex-encoded
         * strings of Clarity values.
         *
         * To convert Clarity values to their hex representation, the `cvToHex`
         * helper from the `@stacks/transactions` package may be helpful.
         *
         * ```js
         * import { cvToHex } from '@stacks/transactions';
         *
         * const functionArgs = [someClarityValue1, someClarityValue2];
         * const hexArgs = functionArgs.map(cvToHex);
         * ```
         */
        readonly functionArgs: v.OptionalSchema<v.ArraySchema<v.StringSchema<undefined>, undefined>, undefined>;
        /**
         * The post conditions to apply to the contract call.
         */
        readonly postConditions: v.OptionalSchema<v.ArraySchema<v.StringSchema<undefined>, undefined>, undefined>;
        /**
         * The mode to apply to the post conditions.
         */
        readonly postConditionMode: v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"allow", undefined>, v.LiteralSchema<"deny", undefined>], undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type StxCallContractRequestMessage = v.InferOutput<typeof stxCallContractRequestMessageSchema>;
type StxCallContract = MethodParamsAndResult<StxCallContractParams, StxCallContractResult>;

declare const stxDeployContractMethodName = "stx_deployContract";
declare const stxDeployContractParamsSchema: v.ObjectSchema<{
    /**
     * Name of the contract.
     */
    readonly name: v.StringSchema<undefined>;
    /**
     * The source code of the Clarity contract.
     */
    readonly clarityCode: v.StringSchema<undefined>;
    /**
     * The version of the Clarity contract.
     */
    readonly clarityVersion: v.OptionalSchema<v.NumberSchema<undefined>, undefined>;
    /**
     * The post conditions to apply to the contract call.
     */
    readonly postConditions: v.OptionalSchema<v.ArraySchema<v.StringSchema<undefined>, undefined>, undefined>;
    /**
     * The mode to apply to the post conditions.
     */
    readonly postConditionMode: v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"allow", undefined>, v.LiteralSchema<"deny", undefined>], undefined>, undefined>;
}, undefined>;
type StxDeployContractParams = v.InferOutput<typeof stxDeployContractParamsSchema>;
declare const stxDeployContractResultSchema: v.ObjectSchema<{
    /**
     * The ID of the transaction.
     */
    readonly txid: v.StringSchema<undefined>;
    /**
     * A Stacks transaction as a hex-encoded string.
     */
    readonly transaction: v.StringSchema<undefined>;
}, undefined>;
type StxDeployContractResult = v.InferOutput<typeof stxDeployContractResultSchema>;
declare const stxDeployContractRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"stx_deployContract", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * Name of the contract.
         */
        readonly name: v.StringSchema<undefined>;
        /**
         * The source code of the Clarity contract.
         */
        readonly clarityCode: v.StringSchema<undefined>;
        /**
         * The version of the Clarity contract.
         */
        readonly clarityVersion: v.OptionalSchema<v.NumberSchema<undefined>, undefined>;
        /**
         * The post conditions to apply to the contract call.
         */
        readonly postConditions: v.OptionalSchema<v.ArraySchema<v.StringSchema<undefined>, undefined>, undefined>;
        /**
         * The mode to apply to the post conditions.
         */
        readonly postConditionMode: v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"allow", undefined>, v.LiteralSchema<"deny", undefined>], undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type StxDeployContractRequestMessage = v.InferOutput<typeof stxDeployContractRequestMessageSchema>;
type StxDeployContract = MethodParamsAndResult<StxDeployContractParams, StxDeployContractResult>;

declare const stxGetAccountsMethodName = "stx_getAccounts";
declare const stxGetAccountsParamsSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type StxGetAccountsParams = v.InferOutput<typeof stxGetAccountsParamsSchema>;
declare const stxGetAccountsResultSchema: v.ObjectSchema<{
    /**
     * The addresses generated for the given purposes.
     */
    readonly addresses: v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly publicKey: v.StringSchema<undefined>;
        readonly gaiaHubUrl: v.StringSchema<undefined>;
        readonly gaiaAppKey: v.StringSchema<undefined>;
    }, undefined>, undefined>;
    readonly network: v.ObjectSchema<{
        readonly bitcoin: v.ObjectSchema<{
            readonly name: v.EnumSchema<typeof BitcoinNetworkType, undefined>;
        }, undefined>;
        readonly stacks: v.ObjectSchema<{
            readonly name: v.StringSchema<undefined>;
        }, undefined>;
    }, undefined>;
}, undefined>;
type StxGetAccountsResult = v.InferOutput<typeof stxGetAccountsResultSchema>;
declare const stxGetAccountsRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"stx_getAccounts", undefined>;
    readonly params: v.NullishSchema<v.NullSchema<undefined>, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type StxGetAccountsRequestMessage = v.InferOutput<typeof stxGetAccountsRequestMessageSchema>;
type StxGetAccounts = MethodParamsAndResult<StxGetAccountsParams, StxGetAccountsResult>;

declare const stxGetAddressesMethodName = "stx_getAddresses";
declare const stxGetAddressesParamsSchema: v.NullishSchema<v.ObjectSchema<{
    /**
     * A message to be displayed to the user in the request prompt.
     */
    readonly message: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
}, undefined>, undefined>;
type StxGetAddressesParams = v.InferOutput<typeof stxGetAddressesParamsSchema>;
declare const stxGetAddressesResultSchema: v.ObjectSchema<{
    /**
     * The addresses generated for the given purposes.
     */
    readonly addresses: v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly publicKey: v.StringSchema<undefined>;
        readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>;
        readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
        readonly walletType: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
    }, undefined>, undefined>;
    readonly network: v.ObjectSchema<{
        readonly bitcoin: v.ObjectSchema<{
            readonly name: v.EnumSchema<typeof BitcoinNetworkType, undefined>;
        }, undefined>;
        readonly stacks: v.ObjectSchema<{
            readonly name: v.StringSchema<undefined>;
        }, undefined>;
    }, undefined>;
}, undefined>;
type StxGetAddressesResult = v.InferOutput<typeof stxGetAddressesResultSchema>;
declare const stxGetAddressesRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"stx_getAddresses", undefined>;
    readonly params: v.NullishSchema<v.ObjectSchema<{
        /**
         * A message to be displayed to the user in the request prompt.
         */
        readonly message: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    }, undefined>, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type StxGetAddressesRequestMessage = v.InferOutput<typeof stxGetAddressesRequestMessageSchema>;
type StxGetAddresses = MethodParamsAndResult<v.InferOutput<typeof stxGetAddressesParamsSchema>, v.InferOutput<typeof stxGetAddressesResultSchema>>;

declare const stxSignMessageMethodName = "stx_signMessage";
declare const stxSignMessageParamsSchema: v.ObjectSchema<{
    /**
     * The message to sign.
     */
    readonly message: v.StringSchema<undefined>;
}, undefined>;
type StxSignMessageParams = v.InferOutput<typeof stxSignMessageParamsSchema>;
declare const stxSignMessageResultSchema: v.ObjectSchema<{
    /**
     * The signature of the message.
     */
    readonly signature: v.StringSchema<undefined>;
    /**
     * The public key used to sign the message.
     */
    readonly publicKey: v.StringSchema<undefined>;
}, undefined>;
type StxSignMessageResult = v.InferOutput<typeof stxSignMessageResultSchema>;
declare const stxSignMessageRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"stx_signMessage", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * The message to sign.
         */
        readonly message: v.StringSchema<undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type StxSignMessageRequestMessage = v.InferOutput<typeof stxSignMessageRequestMessageSchema>;
type StxSignMessage = MethodParamsAndResult<StxSignMessageParams, StxSignMessageResult>;

declare const stxSignStructuredMessageMethodName = "stx_signStructuredMessage";
declare const stxSignStructuredMessageParamsSchema: v.ObjectSchema<{
    /**
     * The domain to be signed.
     */
    readonly domain: v.StringSchema<undefined>;
    /**
     * Message payload to be signed.
     */
    readonly message: v.StringSchema<undefined>;
    /**
     * The public key to sign the message with.
     */
    readonly publicKey: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
}, undefined>;
type StxSignStructuredMessageParams = v.InferOutput<typeof stxSignStructuredMessageParamsSchema>;
declare const stxSignStructuredMessageResultSchema: v.ObjectSchema<{
    /**
     * Signature of the message.
     */
    readonly signature: v.StringSchema<undefined>;
    /**
     * Public key as hex-encoded string.
     */
    readonly publicKey: v.StringSchema<undefined>;
}, undefined>;
type StxSignStructuredMessageResult = v.InferOutput<typeof stxSignStructuredMessageResultSchema>;
declare const stxSignStructuredMessageRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"stx_signStructuredMessage", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * The domain to be signed.
         */
        readonly domain: v.StringSchema<undefined>;
        /**
         * Message payload to be signed.
         */
        readonly message: v.StringSchema<undefined>;
        /**
         * The public key to sign the message with.
         */
        readonly publicKey: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type StxSignStructuredMessageRequestMessage = v.InferOutput<typeof stxSignStructuredMessageRequestMessageSchema>;
type StxSignStructuredMessage = MethodParamsAndResult<StxSignStructuredMessageParams, StxSignStructuredMessageResult>;

declare const stxSignTransactionMethodName = "stx_signTransaction";
declare const stxSignTransactionParamsSchema: v.ObjectSchema<{
    /**
     * The transaction to sign as a hex-encoded string.
     */
    readonly transaction: v.StringSchema<undefined>;
    /**
     * The public key to sign the transaction with. The wallet may use any key
     * when not provided.
     */
    readonly pubkey: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    /**
     * Whether to broadcast the transaction after signing. Defaults to `true`.
     */
    readonly broadcast: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
}, undefined>;
type StxSignTransactionParams = v.InferOutput<typeof stxSignTransactionParamsSchema>;
declare const stxSignTransactionResultSchema: v.ObjectSchema<{
    /**
     * The signed transaction as a hex-encoded string.
     */
    readonly transaction: v.StringSchema<undefined>;
}, undefined>;
type StxSignTransactionResult = v.InferOutput<typeof stxSignTransactionResultSchema>;
declare const stxSignTransactionRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"stx_signTransaction", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * The transaction to sign as a hex-encoded string.
         */
        readonly transaction: v.StringSchema<undefined>;
        /**
         * The public key to sign the transaction with. The wallet may use any key
         * when not provided.
         */
        readonly pubkey: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        /**
         * Whether to broadcast the transaction after signing. Defaults to `true`.
         */
        readonly broadcast: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type StxSignTransactionRequestMessage = v.InferOutput<typeof stxSignTransactionRequestMessageSchema>;
type StxSignTransaction = MethodParamsAndResult<StxSignTransactionParams, StxSignTransactionResult>;

declare const stxSignTransactionsMethodName = "stx_signTransactions";
declare const stxSignTransactionsParamsSchema: v.ObjectSchema<{
    /**
     * The transactions to sign as hex-encoded strings.
     */
    readonly transactions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.CheckAction<string, "Invalid hex-encoded Stacks transaction.">]>, undefined>, v.MinLengthAction<string[], 1, undefined>]>;
    /**
     * Whether the signed transactions should be broadcast after signing. Defaults
     * to `true`.
     */
    readonly broadcast: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
}, undefined>;
type StxSignTransactionsParams = v.InferOutput<typeof stxSignTransactionsParamsSchema>;
declare const stxSignTransactionsResultSchema: v.ObjectSchema<{
    /**
     * The signed transactions as hex-encoded strings, in the same order as in the
     * sign request.
     */
    readonly transactions: v.ArraySchema<v.StringSchema<undefined>, undefined>;
}, undefined>;
type StxSignTransactionsResult = v.InferOutput<typeof stxSignTransactionsResultSchema>;
declare const stxSignTransactionsRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"stx_signTransactions", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * The transactions to sign as hex-encoded strings.
         */
        readonly transactions: v.SchemaWithPipe<readonly [v.ArraySchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.CheckAction<string, "Invalid hex-encoded Stacks transaction.">]>, undefined>, v.MinLengthAction<string[], 1, undefined>]>;
        /**
         * Whether the signed transactions should be broadcast after signing. Defaults
         * to `true`.
         */
        readonly broadcast: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type StxSignTransactionsRequestMessage = v.InferOutput<typeof stxSignTransactionsRequestMessageSchema>;
type StxSignTransactions = MethodParamsAndResult<StxSignTransactionsParams, StxSignTransactionsResult>;

declare const stxTransferStxMethodName = "stx_transferStx";
declare const stxTransferStxParamsSchema: v.ObjectSchema<{
    /**
     * Amount of STX tokens to transfer in microstacks as a string. Anything
     * parseable by `BigInt` is acceptable.
     *
     * Example,
     *
     * ```js
     * const amount1 = 1234;
     * const amount2 = 1234n;
     * const amount3 = '1234';
     * ```
     */
    readonly amount: v.UnionSchema<[v.NumberSchema<undefined>, v.StringSchema<undefined>], undefined>;
    /**
     * The recipeint's principal.
     */
    readonly recipient: v.StringSchema<undefined>;
    /**
     * A string representing the memo.
     */
    readonly memo: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    /**
     * Version of parameter format.
     */
    readonly version: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    /**
     * The mode of the post conditions.
     */
    readonly postConditionMode: v.OptionalSchema<v.NumberSchema<undefined>, undefined>;
    /**
     * A hex-encoded string representing the post conditions.
     *
     * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
     *
     * ```js
     * import { serializePostCondition } from '@stacks/transactions';
     *
     * const postCondition = somePostCondition;
     * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
     * ```
     */
    readonly postConditions: v.OptionalSchema<v.ArraySchema<v.StringSchema<undefined>, undefined>, undefined>;
    /**
     * The public key to sign the transaction with. The wallet may use any key
     * when not provided.
     */
    readonly pubkey: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
}, undefined>;
type StxTransferStxParams = v.InferOutput<typeof stxTransferStxParamsSchema>;
declare const stxTransferStxResultSchema: v.ObjectSchema<{
    /**
     * The ID of the transaction.
     */
    readonly txid: v.StringSchema<undefined>;
    /**
     * A Stacks transaction as a hex-encoded string.
     */
    readonly transaction: v.StringSchema<undefined>;
}, undefined>;
type StxTransferStxResult = v.InferOutput<typeof stxTransferStxResultSchema>;
declare const stxTransferStxRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"stx_transferStx", undefined>;
    readonly params: v.ObjectSchema<{
        /**
         * Amount of STX tokens to transfer in microstacks as a string. Anything
         * parseable by `BigInt` is acceptable.
         *
         * Example,
         *
         * ```js
         * const amount1 = 1234;
         * const amount2 = 1234n;
         * const amount3 = '1234';
         * ```
         */
        readonly amount: v.UnionSchema<[v.NumberSchema<undefined>, v.StringSchema<undefined>], undefined>;
        /**
         * The recipeint's principal.
         */
        readonly recipient: v.StringSchema<undefined>;
        /**
         * A string representing the memo.
         */
        readonly memo: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        /**
         * Version of parameter format.
         */
        readonly version: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        /**
         * The mode of the post conditions.
         */
        readonly postConditionMode: v.OptionalSchema<v.NumberSchema<undefined>, undefined>;
        /**
         * A hex-encoded string representing the post conditions.
         *
         * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
         *
         * ```js
         * import { serializePostCondition } from '@stacks/transactions';
         *
         * const postCondition = somePostCondition;
         * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
         * ```
         */
        readonly postConditions: v.OptionalSchema<v.ArraySchema<v.StringSchema<undefined>, undefined>, undefined>;
        /**
         * The public key to sign the transaction with. The wallet may use any key
         * when not provided.
         */
        readonly pubkey: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type StxTransferStxRequestMessage = v.InferOutput<typeof stxTransferStxRequestMessageSchema>;
type StxTransferStx = MethodParamsAndResult<StxTransferStxParams, StxTransferStxResult>;

declare const accountActionsSchema: v.ObjectSchema<{
    readonly read: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
}, undefined>;
declare const walletActionsSchema: v.ObjectSchema<{
    readonly readNetwork: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
}, undefined>;
declare const accountPermissionSchema: v.ObjectSchema<{
    readonly type: v.LiteralSchema<"account", undefined>;
    readonly resourceId: v.StringSchema<undefined>;
    readonly clientId: v.StringSchema<undefined>;
    readonly actions: v.ObjectSchema<{
        readonly read: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>;
}, undefined>;
declare const walletPermissionSchema: v.ObjectSchema<{
    readonly type: v.LiteralSchema<"wallet", undefined>;
    readonly resourceId: v.StringSchema<undefined>;
    readonly clientId: v.StringSchema<undefined>;
    readonly actions: v.ObjectSchema<{
        readonly readNetwork: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>;
}, undefined>;
/**
 * Permissions with the clientId field omitted and optional actions. Used for
 * permission requests, since the wallet performs authentication based on the
 * client's tab origin and should not rely on the client authenticating
 * themselves.
 */
declare const PermissionRequestParams: v.VariantSchema<"type", [v.ObjectSchema<{
    readonly type: v.LiteralSchema<"account", undefined>;
    readonly resourceId: v.StringSchema<undefined>;
    readonly actions: v.ObjectSchema<{
        readonly read: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>;
}, undefined>, v.ObjectSchema<{
    readonly type: v.LiteralSchema<"wallet", undefined>;
    readonly resourceId: v.StringSchema<undefined>;
    readonly actions: v.ObjectSchema<{
        readonly readNetwork: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>;
}, undefined>], undefined>;
declare const permission: v.VariantSchema<"type", [v.ObjectSchema<{
    readonly type: v.LiteralSchema<"account", undefined>;
    readonly resourceId: v.StringSchema<undefined>;
    readonly clientId: v.StringSchema<undefined>;
    readonly actions: v.ObjectSchema<{
        readonly read: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>;
}, undefined>, v.ObjectSchema<{
    readonly type: v.LiteralSchema<"wallet", undefined>;
    readonly resourceId: v.StringSchema<undefined>;
    readonly clientId: v.StringSchema<undefined>;
    readonly actions: v.ObjectSchema<{
        readonly readNetwork: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>;
}, undefined>], undefined>;
type PermissionWithoutClientId = v.InferOutput<typeof PermissionRequestParams>;
declare const requestPermissionsMethodName = "wallet_requestPermissions";
declare const requestPermissionsParamsSchema: v.NullishSchema<v.ArraySchema<v.VariantSchema<"type", [v.ObjectSchema<{
    readonly type: v.LiteralSchema<"account", undefined>;
    readonly resourceId: v.StringSchema<undefined>;
    readonly actions: v.ObjectSchema<{
        readonly read: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>;
}, undefined>, v.ObjectSchema<{
    readonly type: v.LiteralSchema<"wallet", undefined>;
    readonly resourceId: v.StringSchema<undefined>;
    readonly actions: v.ObjectSchema<{
        readonly readNetwork: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>;
}, undefined>], undefined>, undefined>, undefined>;
type RequestPermissionsParams = v.InferOutput<typeof requestPermissionsParamsSchema>;
declare const requestPermissionsResultSchema: v.LiteralSchema<true, undefined>;
type RequestPermissionsResult = v.InferOutput<typeof requestPermissionsResultSchema>;
declare const requestPermissionsRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_requestPermissions", undefined>;
    readonly params: v.NullishSchema<v.ArraySchema<v.VariantSchema<"type", [v.ObjectSchema<{
        readonly type: v.LiteralSchema<"account", undefined>;
        readonly resourceId: v.StringSchema<undefined>;
        readonly actions: v.ObjectSchema<{
            readonly read: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
        }, undefined>;
    }, undefined>, v.ObjectSchema<{
        readonly type: v.LiteralSchema<"wallet", undefined>;
        readonly resourceId: v.StringSchema<undefined>;
        readonly actions: v.ObjectSchema<{
            readonly readNetwork: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
        }, undefined>;
    }, undefined>], undefined>, undefined>, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type RequestPermissionsRequestMessage = v.InferOutput<typeof requestPermissionsRequestMessageSchema>;
type RequestPermissions = MethodParamsAndResult<RequestPermissionsParams, RequestPermissionsResult>;
declare const renouncePermissionsMethodName = "wallet_renouncePermissions";
declare const renouncePermissionsParamsSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type RenouncePermissionsParams = v.InferOutput<typeof renouncePermissionsParamsSchema>;
declare const renouncePermissionsResultSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type RenouncePermissionsResult = v.InferOutput<typeof renouncePermissionsResultSchema>;
declare const renouncePermissionsRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_renouncePermissions", undefined>;
    readonly params: v.NullishSchema<v.NullSchema<undefined>, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type RenouncePermissionsRequestMessage = v.InferOutput<typeof renouncePermissionsRequestMessageSchema>;
type RenouncePermissions = MethodParamsAndResult<RenouncePermissionsParams, RenouncePermissionsResult>;
declare const disconnectMethodName = "wallet_disconnect";
declare const disconnectParamsSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type DisconnectParams = v.InferOutput<typeof disconnectParamsSchema>;
declare const disconnectResultSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type DisconnectResult = v.InferOutput<typeof disconnectResultSchema>;
declare const disconnectRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_disconnect", undefined>;
    readonly params: v.NullishSchema<v.NullSchema<undefined>, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type DisconnectRequestMessage = v.InferOutput<typeof disconnectRequestMessageSchema>;
type Disconnect = MethodParamsAndResult<DisconnectParams, DisconnectResult>;
declare const getWalletTypeMethodName = "wallet_getWalletType";
declare const getWalletTypeParamsSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type GetWalletTypeParams = v.InferOutput<typeof getWalletTypeParamsSchema>;
declare const getWalletTypeResultSchema: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
type GetWalletTypeResult = v.InferOutput<typeof getWalletTypeResultSchema>;
declare const getWalletTypeRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_getWalletType", undefined>;
    readonly params: v.NullishSchema<v.NullSchema<undefined>, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type GetWalletTypeRequestMessage = v.InferOutput<typeof getWalletTypeRequestMessageSchema>;
type GetWalletType = MethodParamsAndResult<GetWalletTypeParams, GetWalletTypeResult>;
declare const getCurrentPermissionsMethodName = "wallet_getCurrentPermissions";
declare const getCurrentPermissionsParamsSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type GetCurrentPermissionsParams = v.InferOutput<typeof getCurrentPermissionsParamsSchema>;
declare const getCurrentPermissionsResultSchema: v.ArraySchema<v.VariantSchema<"type", [v.ObjectSchema<{
    readonly type: v.LiteralSchema<"account", undefined>;
    readonly resourceId: v.StringSchema<undefined>;
    readonly clientId: v.StringSchema<undefined>;
    readonly actions: v.ObjectSchema<{
        readonly read: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>;
}, undefined>, v.ObjectSchema<{
    readonly type: v.LiteralSchema<"wallet", undefined>;
    readonly resourceId: v.StringSchema<undefined>;
    readonly clientId: v.StringSchema<undefined>;
    readonly actions: v.ObjectSchema<{
        readonly readNetwork: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>;
}, undefined>], undefined>, undefined>;
type GetCurrentPermissionsResult = v.InferOutput<typeof getCurrentPermissionsResultSchema>;
declare const getCurrentPermissionsRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_getCurrentPermissions", undefined>;
    readonly params: v.NullishSchema<v.NullSchema<undefined>, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type GetCurrentPermissionsRequestMessage = v.InferOutput<typeof getCurrentPermissionsRequestMessageSchema>;
type GetCurrentPermissions = MethodParamsAndResult<GetCurrentPermissionsParams, GetCurrentPermissionsResult>;
declare const getNetworkMethodName = "wallet_getNetwork";
declare const getNetworkParamsSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type GetNetworkParams = v.InferOutput<typeof getNetworkParamsSchema>;
declare const getNetworkResultSchema: v.ObjectSchema<{
    readonly bitcoin: v.ObjectSchema<{
        readonly name: v.EnumSchema<typeof BitcoinNetworkType, undefined>;
    }, undefined>;
    readonly stacks: v.ObjectSchema<{
        readonly name: v.StringSchema<undefined>;
    }, undefined>;
}, undefined>;
type GetNetworkResult = v.InferOutput<typeof getNetworkResultSchema>;
declare const getNetworkRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_getNetwork", undefined>;
    readonly params: v.NullishSchema<v.NullSchema<undefined>, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type GetNetworkRequestMessage = v.InferOutput<typeof getNetworkRequestMessageSchema>;
type GetNetwork = MethodParamsAndResult<GetNetworkParams, GetNetworkResult>;
declare const changeNetworkMethodName = "wallet_changeNetwork";
declare const changeNetworkParamsSchema: v.ObjectSchema<{
    readonly name: v.EnumSchema<typeof BitcoinNetworkType, undefined>;
}, undefined>;
type ChangeNetworkParams = v.InferOutput<typeof changeNetworkParamsSchema>;
declare const changeNetworkResultSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type ChangeNetworkResult = v.InferOutput<typeof changeNetworkResultSchema>;
declare const changeNetworkRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_changeNetwork", undefined>;
    readonly params: v.ObjectSchema<{
        readonly name: v.EnumSchema<typeof BitcoinNetworkType, undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type ChangeNetworkRequestMessage = v.InferOutput<typeof changeNetworkRequestMessageSchema>;
type ChangeNetwork = MethodParamsAndResult<ChangeNetworkParams, ChangeNetworkResult>;
declare const changeNetworkByIdMethodName = "wallet_changeNetworkById";
declare const changeNetworkByIdParamsSchema: v.ObjectSchema<{
    readonly id: v.StringSchema<undefined>;
}, undefined>;
type ChangeNetworkByIdParams = v.InferOutput<typeof changeNetworkByIdParamsSchema>;
declare const changeNetworkByIdResultSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type ChangeNetworkByIdResult = v.InferOutput<typeof changeNetworkByIdResultSchema>;
declare const changeNetworkByIdRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_changeNetworkById", undefined>;
    readonly params: v.ObjectSchema<{
        readonly id: v.StringSchema<undefined>;
    }, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type ChangeNetworkByIdRequestMessage = v.InferOutput<typeof changeNetworkByIdRequestMessageSchema>;
type ChangeNetworkById = MethodParamsAndResult<ChangeNetworkByIdParams, ChangeNetworkByIdResult>;
declare const getAccountMethodName = "wallet_getAccount";
declare const getAccountParamsSchema: v.NullishSchema<v.NullSchema<undefined>, undefined>;
type GetAccountParams = v.InferOutput<typeof getAccountParamsSchema>;
declare const getAccountResultSchema: v.ObjectSchema<{
    readonly id: v.StringSchema<undefined>;
    readonly addresses: v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly publicKey: v.StringSchema<undefined>;
        readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>;
        readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
        readonly walletType: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
    }, undefined>, undefined>;
    readonly walletType: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
    readonly network: v.ObjectSchema<{
        readonly bitcoin: v.ObjectSchema<{
            readonly name: v.EnumSchema<typeof BitcoinNetworkType, undefined>;
        }, undefined>;
        readonly stacks: v.ObjectSchema<{
            readonly name: v.StringSchema<undefined>;
        }, undefined>;
    }, undefined>;
}, undefined>;
type GetAccountResult = v.InferOutput<typeof getAccountResultSchema>;
declare const getAccountRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_getAccount", undefined>;
    readonly params: v.NullishSchema<v.NullSchema<undefined>, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type GetAccountRequestMessage = v.InferOutput<typeof getAccountRequestMessageSchema>;
type GetAccount = MethodParamsAndResult<GetAccountParams, GetAccountResult>;
declare const connectMethodName = "wallet_connect";
declare const connectParamsSchema: v.NullishSchema<v.ObjectSchema<{
    readonly permissions: v.OptionalSchema<v.ArraySchema<v.VariantSchema<"type", [v.ObjectSchema<{
        readonly type: v.LiteralSchema<"account", undefined>;
        readonly resourceId: v.StringSchema<undefined>;
        readonly actions: v.ObjectSchema<{
            readonly read: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
        }, undefined>;
    }, undefined>, v.ObjectSchema<{
        readonly type: v.LiteralSchema<"wallet", undefined>;
        readonly resourceId: v.StringSchema<undefined>;
        readonly actions: v.ObjectSchema<{
            readonly readNetwork: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
        }, undefined>;
    }, undefined>], undefined>, undefined>, undefined>;
    readonly addresses: v.OptionalSchema<v.ArraySchema<v.EnumSchema<typeof AddressPurpose, undefined>, undefined>, undefined>;
    readonly message: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.MaxLengthAction<string, 80, "The message must not exceed 80 characters.">]>, undefined>;
    readonly network: v.OptionalSchema<v.EnumSchema<typeof BitcoinNetworkType, undefined>, undefined>;
}, undefined>, undefined>;
type ConnectParams = v.InferOutput<typeof connectParamsSchema>;
declare const connectResultSchema: v.ObjectSchema<{
    readonly id: v.StringSchema<undefined>;
    readonly addresses: v.ArraySchema<v.ObjectSchema<{
        readonly address: v.StringSchema<undefined>;
        readonly publicKey: v.StringSchema<undefined>;
        readonly purpose: v.EnumSchema<typeof AddressPurpose, undefined>;
        readonly addressType: v.EnumSchema<typeof AddressType, undefined>;
        readonly walletType: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
    }, undefined>, undefined>;
    readonly walletType: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
    readonly network: v.ObjectSchema<{
        readonly bitcoin: v.ObjectSchema<{
            readonly name: v.EnumSchema<typeof BitcoinNetworkType, undefined>;
        }, undefined>;
        readonly stacks: v.ObjectSchema<{
            readonly name: v.StringSchema<undefined>;
        }, undefined>;
    }, undefined>;
}, undefined>;
type ConnectResult = v.InferOutput<typeof connectResultSchema>;
declare const connectRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_connect", undefined>;
    readonly params: v.NullishSchema<v.ObjectSchema<{
        readonly permissions: v.OptionalSchema<v.ArraySchema<v.VariantSchema<"type", [v.ObjectSchema<{
            readonly type: v.LiteralSchema<"account", undefined>;
            readonly resourceId: v.StringSchema<undefined>;
            readonly actions: v.ObjectSchema<{
                readonly read: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
            }, undefined>;
        }, undefined>, v.ObjectSchema<{
            readonly type: v.LiteralSchema<"wallet", undefined>;
            readonly resourceId: v.StringSchema<undefined>;
            readonly actions: v.ObjectSchema<{
                readonly readNetwork: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
            }, undefined>;
        }, undefined>], undefined>, undefined>, undefined>;
        readonly addresses: v.OptionalSchema<v.ArraySchema<v.EnumSchema<typeof AddressPurpose, undefined>, undefined>, undefined>;
        readonly message: v.OptionalSchema<v.SchemaWithPipe<readonly [v.StringSchema<undefined>, v.MaxLengthAction<string, 80, "The message must not exceed 80 characters.">]>, undefined>;
        readonly network: v.OptionalSchema<v.EnumSchema<typeof BitcoinNetworkType, undefined>, undefined>;
    }, undefined>, undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type ConnectRequestMessage = v.InferOutput<typeof connectRequestMessageSchema>;
type Connect = MethodParamsAndResult<ConnectParams, ConnectResult>;
declare const addNetworkMethodName = "wallet_addNetwork";
declare const addNetworkParamsSchema: v.VariantSchema<"chain", [v.ObjectSchema<{
    readonly chain: v.LiteralSchema<"bitcoin", undefined>;
    readonly type: v.EnumSchema<typeof BitcoinNetworkType, undefined>;
    readonly name: v.StringSchema<undefined>;
    readonly rpcUrl: v.StringSchema<undefined>;
    readonly rpcFallbackUrl: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    readonly indexerUrl: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    readonly blockExplorerUrl: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    readonly switch: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
}, undefined>, v.ObjectSchema<{
    readonly chain: v.LiteralSchema<"stacks", undefined>;
    readonly name: v.StringSchema<undefined>;
    readonly type: v.EnumSchema<typeof StacksNetworkType, undefined>;
    readonly rpcUrl: v.StringSchema<undefined>;
    readonly blockExplorerUrl: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    readonly switch: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
}, undefined>, v.ObjectSchema<{
    readonly chain: v.LiteralSchema<"starknet", undefined>;
    readonly name: v.StringSchema<undefined>;
    readonly type: v.EnumSchema<typeof StarknetNetworkType, undefined>;
    readonly rpcUrl: v.StringSchema<undefined>;
    readonly blockExplorerUrl: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
    readonly switch: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
}, undefined>], undefined>;
type AddNetworkParams = v.InferOutput<typeof addNetworkParamsSchema>;
declare const addNetworkRequestMessageSchema: v.ObjectSchema<{
    readonly method: v.LiteralSchema<"wallet_addNetwork", undefined>;
    readonly params: v.VariantSchema<"chain", [v.ObjectSchema<{
        readonly chain: v.LiteralSchema<"bitcoin", undefined>;
        readonly type: v.EnumSchema<typeof BitcoinNetworkType, undefined>;
        readonly name: v.StringSchema<undefined>;
        readonly rpcUrl: v.StringSchema<undefined>;
        readonly rpcFallbackUrl: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly indexerUrl: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly blockExplorerUrl: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly switch: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>, v.ObjectSchema<{
        readonly chain: v.LiteralSchema<"stacks", undefined>;
        readonly name: v.StringSchema<undefined>;
        readonly type: v.EnumSchema<typeof StacksNetworkType, undefined>;
        readonly rpcUrl: v.StringSchema<undefined>;
        readonly blockExplorerUrl: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly switch: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>, v.ObjectSchema<{
        readonly chain: v.LiteralSchema<"starknet", undefined>;
        readonly name: v.StringSchema<undefined>;
        readonly type: v.EnumSchema<typeof StarknetNetworkType, undefined>;
        readonly rpcUrl: v.StringSchema<undefined>;
        readonly blockExplorerUrl: v.OptionalSchema<v.StringSchema<undefined>, undefined>;
        readonly switch: v.OptionalSchema<v.BooleanSchema<undefined>, undefined>;
    }, undefined>], undefined>;
    readonly id: v.StringSchema<undefined>;
    readonly jsonrpc: v.LiteralSchema<"2.0", undefined>;
}, undefined>;
type AddNetworkRequestMessage = v.InferOutput<typeof addNetworkRequestMessageSchema>;
declare const addNetworkResultSchema: v.ObjectSchema<{
    readonly id: v.StringSchema<undefined>;
}, undefined>;
type AddNetworkResult = v.InferOutput<typeof addNetworkResultSchema>;
type AddNetwork = MethodParamsAndResult<AddNetworkParams, AddNetworkResult>;

declare const walletTypes: readonly ["software", "ledger", "keystone"];
declare const walletTypeSchema: v.PicklistSchema<readonly ["software", "ledger", "keystone"], undefined>;
type WalletType = v.InferOutput<typeof walletTypeSchema>;

interface StxRequests {
    stx_callContract: StxCallContract;
    stx_deployContract: StxDeployContract;
    stx_getAccounts: StxGetAccounts;
    stx_getAddresses: StxGetAddresses;
    stx_signMessage: StxSignMessage;
    stx_signStructuredMessage: StxSignStructuredMessage;
    stx_signTransaction: StxSignTransaction;
    stx_transferStx: StxTransferStx;
    stx_signTransactions: StxSignTransactions;
}
type StxRequestMethod = keyof StxRequests;
interface BtcRequests {
    getInfo: GetInfo;
    getAddresses: GetAddresses;
    getAccounts: GetAccounts;
    getBalance: GetBalance;
    signMessage: SignMessage;
    sendTransfer: SendTransfer;
    signPsbt: SignPsbt;
}
type BtcRequestMethod = keyof BtcRequests;
interface RunesRequests {
    runes_estimateEtch: RunesEstimateEtch;
    runes_estimateMint: RunesEstimateMint;
    runes_estimateRbfOrder: RunesEstimateRbfOrder;
    runes_etch: RunesEtch;
    runes_getBalance: RunesGetBalance;
    runes_getOrder: RunesGetOrder;
    runes_mint: RunesMint;
    runes_rbfOrder: RunesRbfOrder;
    runes_transfer: RunesTransfer;
}
type RunesRequestMethod = keyof RunesRequests;
interface OrdinalsRequests {
    ord_getInscriptions: GetInscriptions;
    ord_sendInscriptions: SendInscriptions;
}
type OrdinalsRequestMethod = keyof OrdinalsRequests;
interface WalletRequests {
    wallet_addNetwork: AddNetwork;
    wallet_changeNetwork: ChangeNetwork;
    wallet_changeNetworkById: ChangeNetworkById;
    wallet_connect: Connect;
    wallet_disconnect: Disconnect;
    wallet_getAccount: GetAccount;
    wallet_getCurrentPermissions: GetCurrentPermissions;
    wallet_getNetwork: GetNetwork;
    wallet_getWalletType: GetWalletType;
    wallet_renouncePermissions: RenouncePermissions;
    wallet_requestPermissions: RequestPermissions;
}
type Requests = BtcRequests & StxRequests & RunesRequests & WalletRequests & OrdinalsRequests;
type Return<Method> = Method extends keyof Requests ? Requests[Method]['result'] : never;
type Params<Method> = Method extends keyof Requests ? Requests[Method]['params'] : never;

declare const request: <Method extends keyof BtcRequests | keyof StxRequests | keyof RunesRequests | keyof WalletRequests | keyof OrdinalsRequests>(method: Method, params: Params<Method>, providerId?: string) => Promise<RpcResult<Method>>;
declare const addListener: (event: Parameters<AddListener>[0], cb: Parameters<AddListener>[1], providerId?: string) => ReturnType<AddListener>;

declare abstract class SatsConnectAdapter {
    abstract readonly id: string;
    private mintRunes;
    private etchRunes;
    private estimateMint;
    private estimateEtch;
    private getOrder;
    private estimateRbfOrder;
    private rbfOrder;
    request<Method extends keyof Requests>(method: Method, params: Params<Method>): Promise<RpcResult<Method>>;
    abstract addListener: AddListener;
    protected abstract requestInternal<Method extends keyof Requests>(method: Method, params: Params<Method>): Promise<RpcResult<Method>>;
}

declare class BaseAdapter extends SatsConnectAdapter {
    id: string;
    constructor(providerId: string);
    requestInternal: <Method extends keyof BtcRequests | keyof StxRequests | keyof RunesRequests | keyof WalletRequests | keyof OrdinalsRequests>(method: Method, params: Params<Method>) => Promise<RpcResult<Method>>;
    addListener: AddListener;
}

declare const DefaultAdaptersInfo: Record<string, Provider>;
declare const defaultAdapters: Record<string, new () => SatsConnectAdapter>;

export { type AccountChangeEvent, type AddListener, type AddNetwork, type AddNetworkParams, type AddNetworkRequestMessage, type AddNetworkResult, type Address, AddressPurpose, AddressType, BaseAdapter, type BitcoinNetwork, BitcoinNetworkType, type BitcoinProvider, type BtcRequestMethod, type BtcRequests, type Capability, type ChangeNetwork, type ChangeNetworkById, type ChangeNetworkByIdParams, type ChangeNetworkByIdRequestMessage, type ChangeNetworkByIdResult, type ChangeNetworkParams, type ChangeNetworkRequestMessage, type ChangeNetworkResult, type Connect, type ConnectParams, type ConnectRequestMessage, type ConnectResult, type CreateInscriptionOptions, type CreateInscriptionPayload, type CreateInscriptionResponse, type CreateRepeatInscriptionsOptions, type CreateRepeatInscriptionsPayload, type CreateRepeatInscriptionsResponse, DefaultAdaptersInfo, type Disconnect, type DisconnectEvent, type DisconnectParams, type DisconnectRequestMessage, type DisconnectResult, type GetAccount, type GetAccountParams, type GetAccountRequestMessage, type GetAccountResult, type GetAccounts, type GetAccountsParams, type GetAccountsRequestMessage, type GetAccountsResult, type GetAddressOptions, type GetAddressPayload, type GetAddressResponse, type GetAddresses, type GetAddressesParams, type GetAddressesRequestMessage, type GetAddressesResult, type GetBalance, type GetBalanceParams, type GetBalanceRequestMessage, type GetBalanceResult, type GetCapabilitiesOptions, type GetCapabilitiesPayload, type GetCapabilitiesResponse, type GetCurrentPermissions, type GetCurrentPermissionsParams, type GetCurrentPermissionsRequestMessage, type GetCurrentPermissionsResult, type GetInfo, type GetInfoParams, type GetInfoRequestMessage, type GetInfoResult, type GetInscriptions, type GetInscriptionsParams, type GetInscriptionsRequestMessage, type GetInscriptionsResult, type GetNetwork, type GetNetworkParams, type GetNetworkRequestMessage, type GetNetworkResult, type GetWalletType, type GetWalletTypeParams, type GetWalletTypeRequestMessage, type GetWalletTypeResult, type InputToSign, MessageSigningProtocols, type MethodParamsAndResult, type NetworkChangeEvent, type OrdinalsRequestMethod, type OrdinalsRequests, type Params, PermissionRequestParams, type PermissionWithoutClientId, type Provider, type PsbtPayload, type Recipient, type RenouncePermissions, type RenouncePermissionsParams, type RenouncePermissionsRequestMessage, type RenouncePermissionsResult, type RequestOptions, type RequestPayload, type RequestPermissions, type RequestPermissionsParams, type RequestPermissionsRequestMessage, type RequestPermissionsResult, type Requests, type Return, type RpcBase, type RpcError, RpcErrorCode, type RpcErrorResponse, type RpcErrorResponseMessage, type RpcId, RpcIdSchema, type RpcRequest, type RpcRequestMessage, type RpcResponse, type RpcResponseMessage, type RpcResult, type RpcSuccessResponse, type RpcSuccessResponseMessage, type RunesEstimateEtch, type RunesEstimateEtchParams, type RunesEstimateEtchResult, type RunesEstimateMint, type RunesEstimateRbfOrder, type RunesEtch, type RunesEtchParams, type RunesEtchRequestMessage, type RunesEtchResult, type RunesGetBalance, type RunesGetBalanceParams, type RunesGetBalanceResult, type RunesGetOrder, type RunesMint, type RunesMintParams, type RunesMintRequestMessage, type RunesMintResult, type RunesRbfOrder, type RunesRequestMethod, type RunesRequests, type RunesTransfer, type RunesTransferRequestMessage, type RunesTransferResult, SatsConnectAdapter, type SendBtcTransactionOptions, type SendBtcTransactionPayload, type SendBtcTransactionResponse, type SendInscriptions, type SendInscriptionsParams, type SendInscriptionsRequestMessage, type SendInscriptionsResult, type SendTransfer, type SendTransferParams, type SendTransferRequestMessage, type SendTransferResult, type SerializedRecipient, type SerializedSendBtcTransactionPayload, type SignMessage, type SignMessageOptions, type SignMessageParams, type SignMessagePayload, type SignMessageRequestMessage, type SignMessageResponse, type SignMessageResult, type SignMultiplePsbtPayload, type SignMultipleTransactionOptions, type SignMultipleTransactionsPayload, type SignMultipleTransactionsResponse, type SignPsbt, type SignPsbtParams, type SignPsbtRequestMessage, type SignPsbtResult, type SignTransactionOptions, type SignTransactionPayload, type SignTransactionResponse, StacksNetworkType, StarknetNetworkType, type StxCallContract, type StxCallContractParams, type StxCallContractRequestMessage, type StxCallContractResult, type StxDeployContract, type StxDeployContractParams, type StxDeployContractRequestMessage, type StxDeployContractResult, type StxGetAccounts, type StxGetAccountsParams, type StxGetAccountsRequestMessage, type StxGetAccountsResult, type StxGetAddresses, type StxGetAddressesParams, type StxGetAddressesRequestMessage, type StxGetAddressesResult, type StxRequestMethod, type StxRequests, type StxSignMessage, type StxSignMessageParams, type StxSignMessageRequestMessage, type StxSignMessageResult, type StxSignStructuredMessage, type StxSignStructuredMessageParams, type StxSignStructuredMessageRequestMessage, type StxSignStructuredMessageResult, type StxSignTransaction, type StxSignTransactionParams, type StxSignTransactionRequestMessage, type StxSignTransactionResult, type StxSignTransactions, type StxSignTransactionsParams, type StxSignTransactionsRequestMessage, type StxSignTransactionsResult, type StxTransferStx, type StxTransferStxParams, type StxTransferStxRequestMessage, type StxTransferStxResult, type SupportedWallet, type TransferRunesParams, type WalletEvent, type WalletRequests, type WalletType, accountActionsSchema, accountChangeEventName, accountChangeSchema, accountPermissionSchema, addListener, addNetworkMethodName, addNetworkParamsSchema, addNetworkRequestMessageSchema, addNetworkResultSchema, addressSchema, changeNetworkByIdMethodName, changeNetworkByIdParamsSchema, changeNetworkByIdRequestMessageSchema, changeNetworkByIdResultSchema, changeNetworkMethodName, changeNetworkParamsSchema, changeNetworkRequestMessageSchema, changeNetworkResultSchema, connectMethodName, connectParamsSchema, connectRequestMessageSchema, connectResultSchema, createInscription, createRepeatInscriptions, defaultAdapters, disconnectEventName, disconnectMethodName, disconnectParamsSchema, disconnectRequestMessageSchema, disconnectResultSchema, disconnectSchema, getAccountMethodName, getAccountParamsSchema, getAccountRequestMessageSchema, getAccountResultSchema, getAccountsMethodName, getAccountsParamsSchema, getAccountsRequestMessageSchema, getAccountsResultSchema, getAddress, getAddressesMethodName, getAddressesParamsSchema, getAddressesRequestMessageSchema, getAddressesResultSchema, getBalanceMethodName, getBalanceParamsSchema, getBalanceRequestMessageSchema, getBalanceResultSchema, getCapabilities, getCurrentPermissionsMethodName, getCurrentPermissionsParamsSchema, getCurrentPermissionsRequestMessageSchema, getCurrentPermissionsResultSchema, getDefaultProvider, getInfoMethodName, getInfoParamsSchema, getInfoRequestMessageSchema, getInfoResultSchema, getInscriptionsMethodName, getInscriptionsParamsSchema, getInscriptionsRequestMessageSchema, getInscriptionsResultSchema, getNetworkMethodName, getNetworkParamsSchema, getNetworkRequestMessageSchema, getNetworkResultSchema, getProviderById, getProviderOrThrow, getProviders, getSupportedWallets, getWalletTypeMethodName, getWalletTypeParamsSchema, getWalletTypeRequestMessageSchema, getWalletTypeResultSchema, isProviderInstalled, networkChangeEventName, networkChangeSchema, permission, removeDefaultProvider, renouncePermissionsMethodName, renouncePermissionsParamsSchema, renouncePermissionsRequestMessageSchema, renouncePermissionsResultSchema, request, requestPermissionsMethodName, requestPermissionsParamsSchema, requestPermissionsRequestMessageSchema, requestPermissionsResultSchema, rpcErrorResponseMessageSchema, rpcRequestMessageSchema, rpcResponseMessageSchema, rpcSuccessResponseMessageSchema, type runesEstimateMintParams, type runesEstimateMintResult, runesEtchMethodName, runesEtchParamsSchema, runesEtchRequestMessageSchema, runesEtchResultSchema, runesGetBalanceMethodName, runesGetBalanceParamsSchema, type runesGetBalanceRequestMessage, runesGetBalanceRequestMessageSchema, runesGetBalanceResultSchema, runesMintMethodName, runesMintParamsSchema, runesMintRequestMessageSchema, runesMintResultSchema, runesTransferMethodName, runesTransferParamsSchema, runesTransferRequestMessageSchema, runesTransferResultSchema, sendBtcTransaction, sendInscriptionsMethodName, sendInscriptionsParamsSchema, sendInscriptionsRequestMessageSchema, sendInscriptionsResultSchema, sendTransferMethodName, sendTransferParamsSchema, sendTransferRequestMessageSchema, sendTransferResultSchema, setDefaultProvider, signMessage, signMessageMethodName, signMessageParamsSchema, signMessageRequestMessageSchema, signMessageResultSchema, signMultipleTransactions, signPsbtMethodName, signPsbtParamsSchema, signPsbtRequestMessageSchema, signPsbtResultSchema, signTransaction, stxCallContractMethodName, stxCallContractParamsSchema, stxCallContractRequestMessageSchema, stxCallContractResultSchema, stxDeployContractMethodName, stxDeployContractParamsSchema, stxDeployContractRequestMessageSchema, stxDeployContractResultSchema, stxGetAccountsMethodName, stxGetAccountsParamsSchema, stxGetAccountsRequestMessageSchema, stxGetAccountsResultSchema, stxGetAddressesMethodName, stxGetAddressesParamsSchema, stxGetAddressesRequestMessageSchema, stxGetAddressesResultSchema, stxSignMessageMethodName, stxSignMessageParamsSchema, stxSignMessageRequestMessageSchema, stxSignMessageResultSchema, stxSignStructuredMessageMethodName, stxSignStructuredMessageParamsSchema, stxSignStructuredMessageRequestMessageSchema, stxSignStructuredMessageResultSchema, stxSignTransactionMethodName, stxSignTransactionParamsSchema, stxSignTransactionRequestMessageSchema, stxSignTransactionResultSchema, stxSignTransactionsMethodName, stxSignTransactionsParamsSchema, stxSignTransactionsRequestMessageSchema, stxSignTransactionsResultSchema, stxTransferStxMethodName, stxTransferStxParamsSchema, stxTransferStxRequestMessageSchema, stxTransferStxResultSchema, walletActionsSchema, walletEventSchema, walletPermissionSchema, walletTypeSchema, walletTypes };
